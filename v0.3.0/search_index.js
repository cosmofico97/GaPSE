var documenterSearchIndex = {"docs":
[{"location":"Dicts/","page":"Dictionaries and names","title":"Dictionaries and names","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"Dicts/#IMPLEMENTED*GR*EFFECTS-and-so-on","page":"Dictionaries and names","title":"IMPLEMENTEDGREFFECTS and so on","text":"","category":"section"},{"location":"Dicts/","page":"Dictionaries and names","title":"Dictionaries and names","text":"GaPSE.IMPLEMENTED_GR_EFFECTS\nGaPSE.IMPLEMENTED_ξs\nGaPSE.DICT_GR_ξs\nGaPSE.INDEX_GR_EFFECT\nGaPSE.GR_EFFECT_INDEXED","category":"page"},{"location":"Dicts/#GaPSE.IMPLEMENTED_GR_EFFECTS","page":"Dictionaries and names","title":"GaPSE.IMPLEMENTED_GR_EFFECTS","text":" const IMPLEMENTED_GR_EFFECTS = [\n      \"auto_doppler\", \"auto_lensing\",\n      \"auto_localgp\", \"auto_integratedgp\", \n      \n      \"lensing_doppler\", \"doppler_lensing\",\n      \"doppler_localgp\", \"localgp_doppler\",\n      \"doppler_integratedgp\", \"integratedgp_doppler\",\n      \"lensing_localgp\", \"localgp_lensing\",\n      \"lensing_integratedgp\", \"integratedgp_lensing\",\n      \"localgp_integratedgp\", \"integratedgp_localgp\",\n ]\n\nThe names of the GR effects implemented. Their order is associated with the one in IMPLEMENTED_ξs, so be careful to change it.\n\nSee also: IMPLEMENTED_ξs\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.IMPLEMENTED_ξs","page":"Dictionaries and names","title":"GaPSE.IMPLEMENTED_ξs","text":" const IMPLEMENTED_ξs = [\n      ξ_Doppler, ξ_Lensing, ξ_LocalGP, ξ_IntegratedGP, \n      ξ_Lensing_Doppler, ξ_Doppler_Lensing,\n      ξ_Doppler_LocalGP, ξ_LocalGP_Doppler,\n      ξ_Doppler_IntegratedGP, ξ_IntegratedGP_Doppler,\n      ξ_Lensing_LocalGP, ξ_LocalGP_Lensing,\n      ξ_Lensing_IntegratedGP, ξ_IntegratedGP_Lensing,\n      ξ_LocalGP_IntegratedGP, ξ_IntegratedGP_LocalGP\n ]\n\nThe names of the GR effect TPCFs implemented. Their order is associated with the one in IMPLEMENTED_GR_EFFECTS, so be careful to change it.\n\nSee also: IMPLEMENTED_GR_EFFECTS\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.DICT_GR_ξs","page":"Dictionaries and names","title":"GaPSE.DICT_GR_ξs","text":" const DICT_GR_ξs::Dict{String,Function}\n\nFor an input key string effect from IMPLEMENTED_GR_EFFECTS, return the  associated TPCF DICT_GR_ξs[effect] from IMPLEMENTED_ξs.\n\nExample\n\njulia> GaPSE.DICT_GR_ξs[\"auto_doppler\"]\nξ_Doppler\n\nSee also: IMPLEMENTED_GR_EFFECTS, IMPLEMENTED_ξs\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.INDEX_GR_EFFECT","page":"Dictionaries and names","title":"GaPSE.INDEX_GR_EFFECT","text":" const INDEX_GR_EFFECT::Dict{String,Integer}\n\nFor an input key string effect from IMPLEMENTED_GR_EFFECTS, return the  associated index position in that vector.\n\nExample\n\njulia> GaPSE.INDEX_GR_EFFECT[\"auto_doppler\"]\n1\n\nSee also: IMPLEMENTED_GR_EFFECTS\n\n\n\n\n\n","category":"constant"},{"location":"Dicts/#GaPSE.GR_EFFECT_INDEXED","page":"Dictionaries and names","title":"GaPSE.GR_EFFECT_INDEXED","text":" const GR_EFFECT_INDEXED::Dict{Integer,String}\n\nFor an input index position i of IMPLEMENTED_GR_EFFECTS, return the  associated key string effect.\n\nExample\n\njulia> GaPSE.DICT_GR_ξs[1]\n\"auto_doppler\"\n\nSee also: IMPLEMENTED_GR_EFFECTS\n\n\n\n\n\n","category":"constant"},{"location":"SumXiMultipoles/","page":"Sum Xi Multipoles","title":"Sum Xi Multipoles","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"SumXiMultipoles/#The-sum-of-all-the-ξ-multipoles-computation","page":"Sum Xi Multipoles","title":"The sum of all the ξ multipoles computation","text":"","category":"section"},{"location":"SumXiMultipoles/","page":"Sum Xi Multipoles","title":"Sum Xi Multipoles","text":"GaPSE.sum_ξ_multipole\nGaPSE.map_sum_ξ_multipole\nGaPSE.print_map_sum_ξ_multipole","category":"page"},{"location":"SumXiMultipoles/#GaPSE.sum_ξ_multipole","page":"Sum Xi Multipoles","title":"GaPSE.sum_ξ_multipole","text":" sum_ξ_multipole(s1, s, cosmo::Cosmology; \n      kwargs...) ::Tuple{Float64, Vector{Float64}}\n\nEvaluate the multipole of order L of all the GR effects TPCF multipoles and their sum in s1 and a distance s from it for the input Cosmology cosmo.\n\nIt makes a for-loop on the GaPSE.IMPLEMENTED_GR_EFFECTS strings, calling ξ_multipole for each of them. They are currently:\n\nauto_doppler , auto_lensing , auto_localgp , auto_integratedgp , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\n\nOptional arguments\n\nkwards... : all these keyword arguments will be passed to ξ_multipole\n\nReturns\n\nA tuple containing:\n\nthe sum of all the ξ multipoles as first element\na Vector{Float64} with all the values of each ξ; they are ordered following IMPLEMENTED_GR_EFFECTS\n\nSee also: integrand_ξ_multipole, ξ_multipole, map_sum_ξ_multipole, print_map_sum_ξ_multipole, Cosmology, IMPLEMENTED_GR_EFFECTS\n\n\n\n\n\n","category":"function"},{"location":"SumXiMultipoles/#GaPSE.map_sum_ξ_multipole","page":"Sum Xi Multipoles","title":"GaPSE.map_sum_ξ_multipole","text":" map_sum_ξ_multipole(\n      cosmo::Cosmology,\n      v_ss = nothing;\n      s1 = nothing,\n      N_log::Integer = 1000,\n      kwargs...) ::Tuple{Vector{Float64}, Vector{Float64}, Vector{Vector{Float64}}}\n\nEvaluate the multipole of order L of all the GR effects TPCF multipoles and their sum in s1 , for all the s values stored inside v_ss and for the input Cosmology cosmo. If v_ss = nothing, it is set v_ss = 10 .^ range(0, 3, length = N_log). If s1 = nothing, it is set s1 = cosmo.s_eff.\n\nIt makes a for-loop on the GaPSE.IMPLEMENTED_GR_EFFECTS strings, calling map_ξ_multipole for each of them. They are currently:\n\nauto_doppler , auto_lensing , auto_localgp , auto_integratedgp , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\n\nOptional arguments\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input Cosmology.\nN_log::Integer = 1000 : number of points to be used in the default logaritmically-spaced  range for v_ss, i.e. range(0, 3, N_log); it is ignored if v_ss ≠ nothing \nkwards... : all these keyword arguments will be passed to map_ξ_multipole\n\nReturns\n\nA tuple containing:\n\nthe vector v_ss itself as first element;\nthe  Vector{Float64} of the sum of all the ξ multipoles as second one\na Vector{Vector{Float64}} with all the values of each ξ; they are ordered following IMPLEMENTED_GR_EFFECTS\n\nSee also: map_ξ_multipole, sum_ξ_multipole, print_map_sum_ξ_multipole, Cosmology, IMPLEMENTED_GR_EFFECTS\n\n\n\n\n\n","category":"function"},{"location":"SumXiMultipoles/#GaPSE.print_map_sum_ξ_multipole","page":"Sum Xi Multipoles","title":"GaPSE.print_map_sum_ξ_multipole","text":" print_map_sum_ξ_multipole(\n      cosmo::Cosmology,\n      out::String,\n      v_ss = nothing;\n      s1 = nothing,\n      N_log::Integer = 1000,\n      L::Integer = 0,\n      single::Bool = true,\n      kwargs...)\n\nEvaluate the multipole of order L of all the GR effects TPCF multipoles and their sum in s1, for all the s values stored inside v_ss and for the input Cosmology cosmo;  saves the results inside the file out. If v_ss = nothing, it is set v_ss = 10 .^ range(0, 3, length = N_log). If s1 = nothing, it is set s1 = cosmo.s_eff.\n\nIt makes a for-loop on the GaPSE.IMPLEMENTED_GR_EFFECTS strings, calling map_ξ_multipole for each of them. They are currently:\n\nauto_doppler , auto_lensing , auto_localgp , auto_integratedgp , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\n\nOptional arguments\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input Cosmology.\nN_log::Integer = 1000 : number of points to be used in the default logaritmically-spaced  range for v_ss, i.e. range(0, 3, N_log); it is ignored if v_ss ≠ nothing \nL::Integer = 0: order of the Legendre polynomial to be used\nsingle::Bool = true : if true, all the CFs are printed inside the file of the sum, in a  table with 18 columns (first one for v_ss, second for their sum an the next 16 for each effect). Otherwise, a new directory \"allstandalonesCFs\" is created (in the same path given in out) and  they are separately saved in files there placed.\nkwards... : all these keyword arguments will be passed to map_ξ_multipole\n\nSee also: map_ξ_multipole, sum_ξ_multipole, map_sum_ξ_multipole, Cosmology, IMPLEMENTED_GR_EFFECTS\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/","page":"Mathematical Utilities","title":"Mathematical Utilities","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"MathUtils/#Mathematical-Utilities-functions","page":"Mathematical Utilities","title":"Mathematical Utilities functions","text":"","category":"section"},{"location":"MathUtils/","page":"Mathematical Utilities","title":"Mathematical Utilities","text":"GaPSE.warning\n\nGaPSE.derivate_point\nGaPSE.derivate_vector\nGaPSE.spectral_index\nGaPSE.mean_spectral_index\nGaPSE.power_law\nGaPSE.two_power_laws\nGaPSE.power_law_from_data\n\nGaPSE.expanded_left_log\nGaPSE.expanded_right_log\nGaPSE.expanded_IPS\nGaPSE.expanded_Iln\nGaPSE.func_I04_tilde\nGaPSE.expanded_I04_tilde\n\nGaPSE.my_interpolation\nGaPSE.EPLs","category":"page"},{"location":"MathUtils/#GaPSE.derivate_point","page":"Mathematical Utilities","title":"GaPSE.derivate_point","text":" derivate_point(xp, yp, x1, y1, x2, y2)\n\nReturn the derivative in (xp, yp), given the neighboor points (x1,y1) and (x2,y2), with x1 < xp < x2. It is not assumed that x2 - xp = xp - x1.\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.mean_spectral_index","page":"Mathematical Utilities","title":"GaPSE.mean_spectral_index","text":" mean_spectral_index(xs, ys; N::Integer = 1, con = false)\n\nAssuming that the input ys follow a power law distribution,  return the mean spectral index langle S rangle of them.\n\nThe spectral index S of a generic function f = f(x) is defined as:\n\n     S = fracpartial log f(x)partial log x \n          = fracxf(x) fracpartial f(x)partial x \n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.power_law","page":"Mathematical Utilities","title":"GaPSE.power_law","text":" power_law(x, si, b, a) ::Float64\n\nReturn the following y = f(x) \"spurious\" power-law value:\n\ny = f(x) = a + b  x^s\n\nwhere si is the exponent (s), b the coefficient (b) and a is the added constant (a).\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.power_law_from_data","page":"Mathematical Utilities","title":"GaPSE.power_law_from_data","text":" power_law_from_data(xs, ys, p0::Vector{Float64},\n      fit_min::Number, fit_max::Number; con = false)\n\n power_law_from_data(xs, ys, p0::Vector{Float64}; con = false) = \n      power_law_from_data(xs, ys, p0, xs[begin], xs[end]; con = con)\n\nReturns the \"spurious\" power-law coefficients s, b and a obtained from the fitting of the data vectors xs and ys inside the limits fit_min and fit_max.\n\nIf con == false, the returned a is always 0.0, because it is considered the \"pure\" power-law fitting function:\n\n     y = f(x) = b  x^s\n\nwhile if con == false it is used the spurious one:\n\n     y = f(x) = a + b  x^s\n\n(and consequently a may be ≠0).\n\nThe fitting is performed through the function curve_fit of the  LsqFit Julia package, which is based on the least-squares method.\n\nSee also: power_law\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.expanded_IPS","page":"Mathematical Utilities","title":"GaPSE.expanded_IPS","text":" expanded_IPS(ks, pks; k_in = 1e-8, k_end = 3e3, con = false)\n\nGiven the ks and pks of a chosen Power Spectrum, returns the same PS with \"longer tails\", i.e. it is prolonged for higher and lower ks than  the input ones.\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.expanded_Iln","page":"Mathematical Utilities","title":"GaPSE.expanded_Iln","text":" expanded_Iln(PK, l, n; N = 1024, kmin = 1e-4, kmax = 1e3, s0 = 1e-3,\n      fit_left_min = 2.0, fit_left_max = 10.0, p0 = [-1.0, 1.0, 0.0], con = false)\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.func_I04_tilde","page":"Mathematical Utilities","title":"GaPSE.func_I04_tilde","text":" func_I04_tilde(PK, s, kmin, kmax; kwargs...)\n\nReturn the following integral:\n\ntildeI^4_0 (s) = int_0^infty fracmathrmdq2pi^2 \n     q^2  P(q)  fracj_0(q s) - 1(q s)^4\n\nIt is brute-force calcuated with quadgk.\n\nArguments\n\nPK : function that return the Input Power Spectrum\ns : value of s whre the integral must be evaluated\nkmin, kmax : extremes (min and max) of integration\nkwargs... : keyword argruments that must be passed to quadgk, such as rtol or atol\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.EPLs","page":"Mathematical Utilities","title":"GaPSE.EPLs","text":" EPLs(\n      l_si::Float64\n      l_b::Float64\n      l_a::Float64\n      left::Float64\n\n      spline::Dierckx.Spline1D\n\n      r_si::Float64\n      r_b::Float64\n      r_a::Float64\n      right::Float64\n )\n\nContains all the information useful in order to return the value of a spline inside the interval left ≤ x ≤ right and the associated power laws for the edges (with the \"left\" coefficients l_si, l_b and l_a for x < left and the \"right\" ones r_si, r_b and  r_a for x > right)\n\nArguments\n\nl_si, l_b, l_a :: Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the LEFT edge; when an input value x < left is given, the returned one is obtained from power_law with this coefficients ( where, of course, l_si is the exponent, l_b the coefficient and l_a the  spurious adding constant). \nleft::Float64 : the break between the left power-law (for x <left) and the  spline (for x ≥ left); its value is the xs[begin] one.\nspline::Dierckx.Spline1D : spline that interpolates between the real values of the  integral calculated inside the range left ≤ x ≤ right\nright::Float64 : the break between the right power-law (for x ≥ left) and the  spline (for x ≤ right); its value is the xs[end] one.\nr_si, r_b, r_a :: Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the RIGHT edge; when an input value x > right is given, the returned one is obtained from power_law with this coefficients ( where, of course, r_si is the exponent, r_bthe coefficient andr_athe  spurious adding constant).  NOTE: for numerical issues, the \"pure\" power-lawy = f(x) = b + x^s` should be used. \n\nConstructors\n\n`EPLs(xs, ys, p0left::Vector{T1}, p0right::Vector{T2};       Nleft::Integer = 15, Nright::Integer = 15) where {T1<:Real, T2 <:Real}\n\nxs and ys: the input vector of values. \nN_left::Integer = 15 : number of points to be used from the left edge for the left power law-fitting. It shouldn't be too low (< 4) or too high (>100).\nN_right::Integer = 15 : number of points to be used from the right edge for the right power law-fitting. It shouldn't be too low (< 4) or too high (>100).\np0_left::Vector{T1} where T1 <:Real : vector with the initial values for the left power-law fitting; its length must    be 2 (if you want to fit with a pure power-law y = f(x) = b * x^s, so only l_si and l_b     are matter of concern) or 3 (if you want to fit with a spurious power-law y = f(x) = a + b * x^s,    so you are also interested in l_a); in the first case, the considered l_a will be 0.0.    Example: \np0_right::Vector{T1} where T1 <:Real : vector with the initial values for the right power-law fitting; its length must    be 2 (if you want to fit with a pure power-law y = f(x) = b * x^s, so only r_si and r_b     are matter of concern) or 3 (if you want to fit with a spurious power-law y = f(x) = a + b * x^s,    so you are also interested in r_a); in the first case, the considered r_a will be 0.0.    It is recommended to \n\nAll the power-law fitting (both \"pure\" and spurious) are made through the  local function power_law_from_data.\n\nExamples\n\njulia> xs = 10 .^ range(0, 2, length=100);\n\njulia> ys = [1.34e2 * x ^ 2.43 for x in xs];\n\njulia> A = EPLs(xs, ys, [1.0, 1.0], [1.0, 1.0]; N_left = 10, N_right = 10)\n\nSee also: power_law_from_data\n\n\n\n\n\n","category":"type"},{"location":"AutoCorrelations/","page":"Auto Correlations","title":"Auto Correlations","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"AutoCorrelations/#Auto-Correlation-functions","page":"Auto Correlations","title":"Auto-Correlation functions","text":"","category":"section"},{"location":"AutoCorrelations/","page":"Auto Correlations","title":"Auto Correlations","text":"GaPSE.ξ_Doppler\nGaPSE.ξ_Lensing\nGaPSE.ξ_LocalGP\nGaPSE.ξ_IntegratedGP\nGaPSE.integrand_ξ_Lensing\nGaPSE.integrand_ξ_IntegratedGP","category":"page"},{"location":"AutoCorrelations/#GaPSE.ξ_Doppler","page":"Auto Correlations","title":"GaPSE.ξ_Doppler","text":" ξ_Doppler(P1::Point, P2::Point, y, cosmo::Cosmology) :: Float64\n\n ξ_Doppler(s1, s2, y, cosmo::Cosmology) = \n      ξ_Doppler(Point(s1, cosmo), Point(s2, cosmo), y, cosmo)\n\nReturn the Doppler auto-correlation function, defined as follows:\n\nxi^v_parallelv_parallel (s_1 s_2 costheta) \n= D_1 D_2 f_1 f_2 mathcalH_1 mathcalH_2 mathcalR_1 mathcalR_2 \n(J_00 I^0_0(s) + J_02I^0_2(s) + J_04I^0_4(s) + J_20I^2_0(s))\n\nwhere D_1 = D(s_1), D_2 = D(s_2) and so on, mathcalH = a H,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2 and  the J coefficients are given by:\n\nbeginalign*\n    J_00 (s_1 s_2 y)  = frac145 (y^2 s_1 s_2 - 2y(s_1^2 + s_2^2) + 3s_1 s_2) \n    J_02 (s_1 s_2 y)  = frac263 (y^2 s_1 s_2 - 2y(s_1^2 + s_2^2) + 3s_1 s_2) \n    J_04 (s_1 s_2 y)  = frac1105 (y^2 s_1 s_2 - 2y(s_1^2 + s_2^2) + 3s_1 s_2) \n    J_20 (s_1 s_2 y)  = frac13 y s^2\nendalign*\n\nInputs\n\nP1::Point and P2::Point: Point where the CF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on)\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nSee also: Point, Cosmology\n\n\n\n\n\n","category":"function"},{"location":"AutoCorrelations/#GaPSE.ξ_Lensing","page":"Auto Correlations","title":"GaPSE.ξ_Lensing","text":" ξ_Lensing(P1::Point, P2::Point, y, cosmo::Cosmology;\n      en::Float64 = 1e6,\n      Δχ_min::Float64 = 1e-3,\n      N_χs::Integer = 100) :: Float64\n\n ξ_Lensing(s1, s2, y, cosmo::Cosmology; kwargs...) = \n      ξ_Lensing(Point(s1, cosmo), Point(s2, cosmo), y, cosmo; kwargs...)\n\nReturn the Lensing auto-correlation function  xi^kappakappa (s_1 s_2 costheta), defined as follows:\n\nxi^kappakappa (s_1 s_2 costheta) = \nint_0^s_1 mathrmd chi_1 int_0^s_2 mathrmd chi_2 \nfrac12\nfrac\n     mathcalH_0^4 Omega_ mathrmM0^2 D_1 D_2 (chi_1 - s_1)(chi_2 - s_2)\n\n     s_1 s_2 a(chi_1) a(chi_2) \n(J_00  I^0_0(chi) + J_02  I^0_2(chi) + \n     J_31  I^3_1(chi) + J_22  I^2_2(chi))\n\nwhere D_1 = D(chi_1), D_2 = D(chi_2) and so on, mathcalH = a H,  chi = sqrtchi_1^2 + chi_2^2 - 2chi_1chi_2costheta,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2)  and the J coefficients are given by \n\nbeginalign*\n    J_00  = - frac3 chi_1^2 chi_2^24 chi^4 (y^2 - 1) \n               (8 y (chi_1^2 + chi_2^2) - 9 chi_1 chi_2 y^2 - 7 chi_1 chi_2) \n    J_02  = - frac3 chi_1^2 chi_2^22 chi^4 (y^2 - 1)\n               (4 y (chi_1^2 + chi_2^2) - 3 chi_1 chi_2 y^2 - 5 chi_1 chi_2) \n    J_31  = 9 y chi^2 \n    J_22  = frac9 chi_1 chi_24 chi^4\n                2 (chi_1^4 + chi_2^4) (7 y^2 - 3) \n                 - 16 y chi_1 chi_2 (chi_1^2 + chi_2^2) (y^2+1) \n               + chi_1^2 chi_2^2 (11 y^4 + 14 y^2 + 23)\nendalign*\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_Lensing.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nΔχ_min::Float64 = 1e-6 : when Deltachi = sqrtchi_1^2 + chi_2^2 - 2  chi_1 chi_2 y to 0^+, some I_ell^n term diverges, but the overall parenthesis has a known limit:\n   lim_chito0^+ (J_00  I^0_0(chi) + J_02  I^0_2(chi) + \n        J_31  I^3_1(chi) + J_22  I^2_2(chi)) = \n        frac415  (5  sigma_2 + frac23  σ_0 s_1^2  chi_2^2)\nSo, when it happens that chi  Deltachi_mathrmmin, the function considers this limit as the result of the parenthesis instead of calculating it in the normal way; it prevents computational divergences.\nN_χs::Integer = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s1) (for χ2); it has been checked that with N_χs ≥ 50 the result is stable.\n\nSee also: integrand_ξ_Lensing, integrand_on_mu_Lensing integral_on_mu, ξ_multipole\n\n\n\n\n\n","category":"function"},{"location":"AutoCorrelations/#GaPSE.ξ_LocalGP","page":"Auto Correlations","title":"GaPSE.ξ_LocalGP","text":" ξ_LocalGP(P1::Point, P2::Point, y, cosmo::Cosmology) :: Float64\n\n ξ_LocalGP(s1, s2, y, cosmo::Cosmology) = \n      ξ_LocalGP(Point(s1, cosmo), Point(s2, cosmo), y, cosmo::Cosmology)\n\nReturn the local gravitational potential auto-correlation function,  defined as follows:\n\nxi^phiphi (s_1 s_2 costheta) = \n     frac9 mathcalH_0^4 Omega_M0^2 D(s_1) D(s_2)s^44 a(s_1) a(s_2)\n     (1 + mathcalR_1 + mathcalR_2 + mathcalR_1mathcalR_2)\n     tildeI^4_0(s)\n\nwhere D_1 = D(s_1), D_2 = D(s_2) and so on, mathcalH = a H,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2 and:\n\ntildeI^4_0 (s) = int_0^infty fracmathrmdq2pi^2 \n          q^2  P(q)  fracj_0(q s) - 1(q s)^4\n\nInputs\n\nP1::Point and P2::Point: Point where the CF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on)\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nSee also: Point, Cosmology\n\n\n\n\n\n","category":"function"},{"location":"AutoCorrelations/#GaPSE.ξ_IntegratedGP","page":"Auto Correlations","title":"GaPSE.ξ_IntegratedGP","text":" ξ_IntegratedGP(P1::Point, P2::Point, y, cosmo::Cosmology; \n      en::Float64 = 1e10,\n      N_χs::Integer = 100) :: Float64\n\n ξ_IntegratedGP(s1, s2, y, cosmo::Cosmology; kwargs...) = \n      ξ_IntegratedGP(Point(s1, cosmo), Point(s2, cosmo), y, cosmo; kwargs...)\n\nReturn the integrated gravitational potential auto-correlation function  xi^intphiintphi(s_1 s_2 costheta), defined as follows:\n\nxi^intphiintphi (s_1 s_2 costheta) = \n     int_0^s_1 mathrmd chi_1 int_0^s_2mathrmd chi_2 \n     J_40(s_1 s_2 y chi_1 chi_2)  tildeI^4_0(chi)\n\nwhere chi = sqrtchi_1^2 + chi_2^2 - 2  chi_1  chi_2  y, y = costheta = hatmathbfs_1 cdot hatmathbfs_2 and:\n\nbeginsplit\n     J_40(s_1 s_2 y chi_1 chi_2)  = \n          frac\n               9 mathcalH_0^4 Omega_M0^2 D(chi_1) D(chi_2) chi^4\n              a(chi_1) a(chi_2) s_1 s_2 \n          (s_2 mathcalH(chi_2) mathcalR(s_2) (f(chi_2)-1) - 1) \n          (s_1 mathcalH(chi_1) mathcalR(s_1) (f(chi_1)-1) - 1)5pt\n     tildeI^4_0 (s) = int_0^infty fracmathrmdq2pi^2 \n          q^2  P(q)  fracj_0(q s) - 1(q s)^4\nendsplit\n\nand P(q) is the input power spectrum.\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_Lensing.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e10: just a float number used in order to deal better  with small numbers.\nN_χs::Integer = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s1) (for χ2); it has been checked that with N_χs ≥ 50 the result is stable.\n\nSee also: integrand_ξ_IntegratedGP, integrand_on_mu_IntegratedGP integral_on_mu, ξ_multipole\n\n\n\n\n\n","category":"function"},{"location":"AutoCorrelations/#GaPSE.integrand_ξ_Lensing","page":"Auto Correlations","title":"GaPSE.integrand_ξ_Lensing","text":" integrand_ξ_Lensing(\n      IP1::Point, IP2::Point,\n      P1::Point, P2::Point,\n      y, cosmo::Cosmology;\n      Δχ_min::Float64 = 1e-4) :: Float64\n\nReturn the integrand of the Lensing auto-correlation function  xi^kappakappa (s_1 s_2 costheta), i.e. the function  f(s_1 s_2 y chi_1 chi_2) defined as follows:  \n\nf(s_1 s_2 y chi_1 chi_2) = \nfrac12\nfrac\n     mathcalH_0^4 Omega_ mathrmM0^2 D_1 D_2 (chi_1 - s_1)(chi_2 - s_2)\n\n     s_1 s_2 a(chi_1) a(chi_2) \n(J_00  I^0_0(chi) + J_02  I^0_2(chi) + \n     J_31  I^3_1(chi) + J_22  I^2_2(chi))\n\nwhere D_1 = D(chi_1), D_2 = D(chi_2) and so on, mathcalH = a H,  chi = sqrtchi_1^2 + chi_2^2 - 2chi_1chi_2costheta,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2)  and the J coefficients are given by \n\nbeginalign*\n    J_00  = - frac3 chi_1^2 chi_2^24 chi^4 (y^2 - 1) \n               (8 y (chi_1^2 + chi_2^2) - 9 chi_1 chi_2 y^2 - 7 chi_1 chi_2) \n    J_02  = - frac3 chi_1^2 chi_2^22 chi^4 (y^2 - 1)\n               (4 y (chi_1^2 + chi_2^2) - 3 chi_1 chi_2 y^2 - 5 chi_1 chi_2) \n    J_31  = 9 y chi^2 \n    J_22  = frac9 chi_1 chi_24 chi^4\n                2 (chi_1^4 + chi_2^4) (7 y^2 - 3) \n                 - 16 y chi_1 chi_2 (chi_1^2 + chi_2^2) (y^2+1) \n               + chi_1^2 chi_2^2 (11 y^4 + 14 y^2 + 23)\nendalign*\n\nInputs\n\nIP1::Point and IP2::Point: Point inside the integration limits, placed  at comoving distance χ1 and χ2 respectively.\nP1::Point and P2::Point: extreme Point of the integration, placed  at comoving distance s1 and s2 respectively.\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nΔχ_min::Float64 = 1e-6 : when Deltachi = sqrtchi_1^2 + chi_2^2 - 2  chi_1 chi_2 y to 0^+, some I_ell^n term diverges, but the overall parenthesis has a known limit:\n   lim_chito0^+ (J_00  I^0_0(chi) + J_02  I^0_2(chi) + \n        J_31  I^3_1(chi) + J_22  I^2_2(chi)) = \n        frac415  (5  sigma_2 + frac23  σ_0 s_1^2  chi_2^2)\nSo, when it happens that chi  Deltachi_mathrmmin, the function considers this limit as the result of the parenthesis instead of calculating it in the normal way; it prevents computational divergences.\n\nSee also: ξ_Lensing, integrand_on_mu_Lensing integral_on_mu, ξ_multipole\n\n\n\n\n\n","category":"function"},{"location":"AutoCorrelations/#GaPSE.integrand_ξ_IntegratedGP","page":"Auto Correlations","title":"GaPSE.integrand_ξ_IntegratedGP","text":" integrand_ξ_IntegratedGP(IP1::Point, IP2::Point,\n      P1::Point, P2::Point,\n      y, cosmo::Cosmology) :: Float64\n\nReturn the integrand of the integrated gravitational potential  auto-correlation function xi^intphiintphi (s_1 s_2 costheta),  i.e. the function f(s_1 s_2 y chi_1 chi_2) defined as follows:  \n\nf(s_1 s_2 y chi_1 chi_2) = J_40(s_1 s_2 y chi_1 chi_2) tildeI^4_0(chi)\n\nwhere chi = sqrtchi_1^2 + chi_2^2 - 2  chi_1  chi_2  y, y = costheta = hatmathbfs_1 cdot hatmathbfs_2 and:\n\nbeginsplit\n     J_40(s_1 s_2 y chi_1 chi_2)  = \n          frac\n                    9 mathcalH_0^4 Omega_M0^2 D(chi_1) D(chi_2) chi^4\n              a(chi_1) a(chi_2) s_1 s_2 \n          (s_2 mathcalH(chi_2) mathcalR(s_2) (f(chi_2)-1) - 1) \n          (s_1 mathcalH(chi_1) mathcalR(s_1) (f(chi_1)-1) - 1)5pt\n     tildeI^4_0 (s) = int_0^infty fracmathrmdq2pi^2 \n          q^2  P(q)  fracj_0(q s) - 1(q s)^4\nendsplit\n\nInputs\n\nIP1::Point and IP2::Point: Point inside the integration limits, placed  at comoving distance χ1 and χ2 respectively.\nP1::Point and P2::Point: extreme Point of the integration, placed  at comoving distance s1 and s2 respectively.\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nSee also: ξ_IntegratedGP, integrand_on_mu_IntegratedGP integral_on_mu, ξ_multipole\n\n\n\n\n\n","category":"function"},{"location":"IPSTools/","page":"Input Power Spectrum Tools","title":"Input Power Spectrum Tools","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"IPSTools/#Tool-functions","page":"Input Power Spectrum Tools","title":"Tool functions","text":"","category":"section"},{"location":"IPSTools/","page":"Input Power Spectrum Tools","title":"Input Power Spectrum Tools","text":"GaPSE.InputPS\nGaPSE.IntegralIPS\nGaPSE.IPSTools","category":"page"},{"location":"IPSTools/#GaPSE.InputPS","page":"Input Power Spectrum Tools","title":"GaPSE.InputPS","text":" InputPS(\n      l_si::Float64\n      l_b::Float64\n      l_a::Float64\n      left::Float64\n\n      spline::Dierckx.Spline1D\n      \n      r_si::Float64\n      r_b::Float64\n      r_a::Float64\n      right::Float64)\n\nStore the Input Power Spectrum.\n\nArguments\n\nl_si, l_b, l_a :: Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the LEFT edge; when an input value x < left is given, the returned one is obtained from power_law with this coefficients ( where, of course, l_si is the exponent, l_b the coefficient and l_a the  spurious adding constant). \nleft::Float64 : the break between the left power-law (for x <left) and the  spline (for x ≥ left); its value is the fit_min of the used constructor.\nspline::Dierckx.Spline1D : spline that interpolates between the real values of the  power spectrum inside the range left ≤ x ≤ right\nright::Float64 : the break between the right power-law (for x > left) and the  spline (for x ≤ right); its value is the fit_max of the used constructor.\nr_si, r_b, r_a :: Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the RIGHT edge; when an input value x > right is given, the returned one is obtained from power_law with this coefficients ( where, of course, r_si is the exponent, r_bthe coefficient andrathe  spurious adding constant).  NOTE: for numerical issues, only the \"pure\" power-lawy = f(x) = b + x^scan be used.  In other words, it always setra = 0.0`.\n\nConstructors\n\nInputPS(file::String; fit_left_min = 1e-6, fit_left_max = 3e-6,    fit_right_min = 1e1, fit_right_max = 2e1) : read the IPS from the given input file; it can contain comments (defined with a  starting # on each line), but the file structure must be space-separated in two colums (former for k values, latter for P ones).\nfit_left_min = 1e-6, fit_left_max = 3e-6 : the limits (min and max) where the PS must be fitted with a power law, for small wavenumbers. \nfit_right_min = 1e1, fit_right_max = 2e1 : the limits (min and max) where the PS must be fitted with a power law, for high wavenumbers. \n\nInputPS(ks::AbstractVector{T1}, pks::AbstractVector{T2}; fit_left_min = 1e-6, fit_left_max = 3e-6,    fit_right_min = 1e1, fit_right_max = 2e1)\nks::AbstractVector{T1}, pks::AbstractVector{T2} : self-explanatory ks and pks array-like values.\nfit_left_min = 1e-6, fit_left_max = 3e-6 : the limits (min and max) where the PS must be fitted with a power law, for small wavenumbers. \nfit_right_min = 1e1, fit_right_max = 2e1 : the limits (min and max) where the PS must be fitted with a power law, for high wavenumbers. \n\nAll the power-law fitting (both \"pure\" and spurious) are made through the  local function power_law_from_data.\n\nSee also: power_law_from_data\n\n\n\n\n\n","category":"type"},{"location":"IPSTools/#GaPSE.IntegralIPS","page":"Input Power Spectrum Tools","title":"GaPSE.IntegralIPS","text":" IntegralIPS(\n      l_si::Float64\n      l_b::Float64\n      l_a::Float64\n      left::Float64\n\n      spline::Dierckx.Spline1D\n\n      r_si::Float64\n      r_b::Float64\n      r_a::Float64\n      right::Float64\n )\n\nContains all the information useful in order to return the value of an integral obtained from the Input Power Spectrum.\n\nArguments\n\nl_si, l_b, l_a :: Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the LEFT edge; when an input value x < left is given, the returned one is obtained from power_law with this coefficients ( where, of course, l_si is the exponent, l_b the coefficient and l_a the  spurious adding constant). \nleft::Float64 : the break between the left power-law (for x <left) and the  spline (for x ≥ left); its value is the fit_min of the used constructor.\nspline::Dierckx.Spline1D : spline that interpolates between the real values of the  integral calculated inside the range left ≤ x ≤ right\nright::Float64 : the break between the right power-law (for x > left) and the  spline (for x ≤ right); its value is the fit_max of the used constructor.\nr_si, r_b, r_a :: Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the RIGHT edge; when an input value x > right is given, the returned one is obtained from power_law with this coefficients ( where, of course, r_si is the exponent, r_bthe coefficient andrathe  spurious adding constant).  NOTE: for numerical issues, only the \"pure\" power-lawy = f(x) = b + x^scan be used.  In other words, it always setra = 0.0`.\n\nConstructors\n\nThere are two type of integrals we are interested in, and so two constructors are here provided:\n\nIntegralIPS(ips, l, n; N::Integer = 1024, kmin = 1e-4, kmax = 1e3, s0 = 1e-3,    fit_left_min = 2.0, fit_left_max = 10.0, p0_left = nothing, con = false,    fit_right_min = nothing, fit_right_max = nothing, p0_right = nothing) This is the one used for the \"classical\" I_ell_n integrals:\nI_ell^n(s) = int_0^infty fracmathrmd q2 pi^2 q^2  P(q) \n   fracj_ell(qs)(qs)^n\nwhere, for a generic Iab name, ell is the FIRST number (a) and  n the second (b). The integral obtained with this constructor is calculated through xicalc, and expanded with power-laws at the edges.\nips: the function/spline that gives the Input Power Spectrum\nl and n: self-explanatory degree of the integral, with the convenction above mentioned\nkmin = 1e-4, kmax = 1e3, s0 = 1e-3 : values to be passed to xicalc for the integration\nfit_left_min = 2.0, fit_left_max = 10.0, : the limits (min and max) where the integral I_ell^n must be fitted with a power law, for small distances. This operation is necessary, because xicalc, in this context, gives wrong results for too small input distance s; nevertheless, all these I_ell^n integrals have fixed power-law trends for s rightarrow 0, so this approach gives good results.\np0_left = nothing : vector with the initial values for the left power-law fitting; its length must be 2 (if you want to fit with a pure power-law y = f(x) = b * x^s, so only l_si and l_b  are matter of concern) or 3 (if you want to fit with a spurious power-law y = f(x) = a + b * x^s, so you are also interested in l_a), depending on the value of con; if nothing, it will be automatically set p0 = [-1.0, 1.0, 0.0] for con==true and p0 = [-1.0, 1.0] for con==false.\ncon::Bool = false : do you want that the fit of all the I_ell^n for the LEFT edge is not a simple power-law y = f(x) = b  x^s, but also consider a constant a, such that y = f(x) = a + b  x^s? For the LEFT side, there is not a lot of difference empirically.  For the RIGHT side, there is not such an option due to numerical problems (it's like  is always set con==false).\nfit_right_min = nothing, fit_right_max = nothing : the limits (min and max) where the integral I_ell^n must be fitted with a power law, for high distances.  These I_ell^n integrals have fixed power-law trends for s rightarrow infty, so this approach gives good results. If nothing, the last 15 points returned from xicalc are used for this fitting. NOTE: for numerical issues, only the \"pure\" power-law y = f(x) = b + x^s can be used. \np0_right = nothing : vector with the initial values for the left power-law fitting; its length must be 2 (to fit with a pure power-law y = f(x) = b * x^s, so only r_si and r_b  are matter of concern); if nothing, it will be automatically set p0 = [-4.0, 1.0, 0.0].\n\nIntegralIPS(ips, func::Function; N::Integer = 1024, kmin = 1e-4, kmax = 1e3,    fit_left_min = 0.1, fit_left_max = 1.0, p0_left = nothing, con = false,    fit_right_min = nothing, fit_right_max = nothing, p0_right = nothing,    kwargs...) This is the one used for the \"strange\" tildeI integrals, such as:\ntildeI^4_0 (s) = int fracmathrmdq2pi^2  q^2  \n   P(q)   fracj_0(qs) - 1(qs)^4 \nThe integral obtained with this constructor is calculated through the input function func, and expanded with power-laws at the edges. For \\tilde{I}^4_0, the function is func_I04_tilde.  \nips: the function/spline that gives the Input Power Spectrum\nfunc: function that return the value of this specific integral in a given value\nkmin = 1e-4, kmax = 1e3, s0 = 1e-3 : values to be passed to func as extremes of integration\nfit_left_min = 0.1, fit_left_max = 1.0, : the limits (min and max) where the integral tildeI must be fitted with a power law, for small distances. This operation is necessary, because xicalc, in this context, gives wrong results for too small input distance s; nevertheless, all this tildeI integral have fixed power-law trends for s rightarrow 0, so this approach gives good results.\np0_left = nothing : vector with the initial values for the left power-law fitting; its length must be 2 (if you want to fit with a pure power-law y = f(x) = b * x^s, so only l_si and l_b  are matter of concern) or 3 (if you want to fit with a spurious power-law y = f(x) = a + b * x^s, so you are also interested in l_a), depending on the value of con; if nothing, it will be automatically set p0 = [-2.0, -1.0, 0.0] for con==true and p0 = [-2.0, -1.0] for con==false.\ncon::Bool = false : do you want that the fit of all the I_ell^n for the LEFT edge is not a simple power-law y = f(x) = b  x^s, but also consider a constant a, such that y = f(x) = a + b  x^s? For the LEFT side, there is not a lot of difference empirically.  For the RIGHT side, there is not such an option due to numerical problems (it's like  is always set con==false).\nfit_right_min = nothing, fit_right_max = nothing : the limits (min and max) where the integral I_ell^n must be fitted with a power law, for high distances.  These I_ell^n integrals have fixed power-law trends for s rightarrow infty, so this approach gives good results. If nothing, the last 15 points returned from xicalc are used for this fitting. NOTE: for numerical issues, only the \"pure\" power-law y = f(x) = b + x^s can be used. \np0_right = nothing : vector with the initial values for the left power-law fitting; its length must be 2 (to fit with a pure power-law y = f(x) = b * x^s, so only r_si and r_b  are matter of concern); if nothing, it will be automatically set p0 = [-4.0, -1.0].\n\nAll the power-law fitting (both \"pure\" and spurious) are made through the  local function power_law_from_data.\n\nSee also: power_law_from_data, func_I04_tilde\n\n\n\n\n\n","category":"type"},{"location":"IPSTools/#GaPSE.IPSTools","page":"Input Power Spectrum Tools","title":"GaPSE.IPSTools","text":" IPSTools(\n      I00::IntegralIPS\n      I20::IntegralIPS\n      I40::IntegralIPS\n      I02::IntegralIPS\n      I22::IntegralIPS\n      I31::IntegralIPS\n      I13::IntegralIPS\n      I11::IntegralIPS\n\n      I04_tilde::IntegralIPS\n\n      σ_0::Float64\n      σ_1::Float64\n      σ_2::Float64\n      σ_3::Float64\n\n      fit_min::Union{Float64,Nothing}\n      fit_max::Union{Float64,Nothing}\n      k_min::Float64\n      k_max::Float64\n      s_0::Float64\n      )\n\nStruct that contains all the useful functions and values obtained from the  Input Power Spectrum.\n\nArguments\n\nI00, I20, I40, I02, I22, I31, I13, I11 ::IntegralIPS: they return the value of the corresponding integral:\nI_ell^n(s) = int_0^infty fracmathrmd q2 pi^2 q^2  P(q) \n   fracj_ell(qs)(qs)^n\nwhere, for a generic Iab name, ell is the FIRST number (a) and  n the second (b). These integrals are performed through xicalc, with kmin, kmax, s0 = 1e-5, 1e3, 1e-3; at the edges they are fitted with power laws (for s < fit_min and  s > max_s_returned_from_xi_calc).\nI04_tilde::IntegralIPS: it returns the value of the integral:\ntildeI^4_0 (s) = int fracmathrmdq2pi^2  q^2  \n   P(q)   fracj_0(qs) - 1(qs)^4 \nThis integral is calculated brute-force with quadgk, and fitted with power-laws at the edges (for s < 0.1 and s > 1e4).\nσ_0, σ_1, σ_2, σ_3 :: Float64: these are the results of the following integral:\nsigma_i = int_k_mathrmmin^k_mathrmmax fracmathrmd q2 pi^2  q^2-i  P(q)\nfit_min, fit_max :: Float64: the limits (min and max) where the integral I_ell^n must be fitted with a power law, for small distances. This operation is necessary, because xicalc, in this context, gives wrong results for too small input distance s; nevertheless, all these I_ell^n integrals have fixed power-law trends for s rightarrow 0, so this approach gives good results.\nk_min k_max::Float64 : because some of the sigma_i integrals from q = 0 to q = +infty diverge, it is common practice to cut the integrals at the edges, so they are calculated from q = k_mathrmmin to q = k_mathrmmax\n\nConstructors\n\nIPSTools(ips::InputPS; N::Integer = 1024,      fit_min::Float64 = 0.05, fit_max::Float64 = 0.5,      k_min::Float64 = 1e-6, k_max::Float64 = 10.0      con::Bool = false      )\n\nips::InputPS : the Input Power Spectrum to be used in all the calculations.\nN::Integer = 1024 : number of points to be used in the xicalc function\nk_min::Float64 = 1e-6, k_max::Float64 = 10.0 : integrations extremes of  the sigma_is\ncon::Bool = false : do you want that the fit of all the I_ell^n for the LEFT edge is not a simple power-law y = f(x) = b  x^s, but also consider a constant a, such that y = f(x) = a + b  x^s? For the LEFT side, there is not a lot of difference empirically.  For the RIGHT side, there is not such an option due to numerical problems (it's like  is always set con==false).\n\nSee also: IntegralIPS, InputPS\n\n\n\n\n\n","category":"type"},{"location":"WindowF/","page":"The F window function","title":"The F window function","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"WindowF/#The-F-window-function","page":"The F window function","title":"The F window function","text":"","category":"section"},{"location":"WindowF/","page":"The F window function","title":"The F window function","text":"GaPSE.F\nGaPSE.F_map\nGaPSE.integrand_F\nGaPSE.WindowF\nGaPSE.spline_F","category":"page"},{"location":"WindowF/#GaPSE.F","page":"The F window function","title":"GaPSE.F","text":" F(x, μ; θ_max = π/2, tolerance = 1e-8, \n      atol = 1e-2, rtol = 1e-5, \n      kwargs...) ::Tuple{Float64, Float64}\n\nThe function F(xmu theta_mathrmmax), defined as follows:\n\nbeginsplit\nF(xmu theta_mathrmmax) =  4pi \n    int_0^theta_mathrmmax mathrmdtheta_1 int_0^pi mathrmd theta  \n     Thetaleft(frac\n        x cos theta + cos theta_1sqrtx^1+2+2xmu - \n        cos(theta_mathrmmax) \n        right) \n     Theta(mu-cos(theta+theta_1)) \n    Theta(cos(theta - theta_1)-mu) \n    fracsinthetasintheta_1\n        sqrt(sinthetasintheta_1)^2-(costhetacostheta_1-mu)^2\nendsplit\n\ntolerance is a parameter needed in case of small negative denominator: the Heaviside theta function mathematically prevent that  mathrmden=(sinthetasintheta_1)^2-(costhetacostheta_1-mu)^2 becomes negative, but computationally might happen that mathrmden results as a very small negative number (for instance -1.2368946523-18); in this case tolerance solve the problem, returning 0 if 0-mathrmden mathrmtolerance.\n\nThe double integral is performed with hcubature function from the Julia Package HCubature; rtol, atol and all the kwargs insert into F  are directly transferred to hcubature. \n\nPAY ATTENTION: do not set too small atol and rtol, or the computation can easily become overwhelming! \n\nSee also: F_map, integrand_F, check_compatible_dicts\n\n\n\n\n\n","category":"function"},{"location":"WindowF/#GaPSE.F_map","page":"The F window function","title":"GaPSE.F_map","text":" F_map(x_step::Float64 = 0.01, μ_step::Float64 = 0.01;\n      out = \"data/F_map.txt\", x1 = 0, x2 = 3, μ1 = -1, μ2 = 1, \n      Fmap_opts::Dict = Dict{Symbol,Any}(), \n      kwargs...)\n\n F_map(xs::Vector{Float64}, μs::Vector{Float64};\n      out = \"data/F_map.txt\", Fmap_opts::Dict = Dict{Symbol,Any}(),\n      kwargs...)\n\nEvaluate the window function F(xmu theta_mathrmmax) in a rectangual grid  of mu and x values, and print the results in the out file.\n\nIn the first method you specify start, stop and step for x and μ manually, while with the second one you pass the values (through a vector )you want to calculate  the function in.\n\nConcerning how the dict works, you may pass only the key and the value you are interested in, and all the other default ones will be considered. For example, if you set:\n\nFmap_opts = Dict(:tolerance => 1e-5, :θ_max => 2.0)\n\nthen the dictionary with all the options that will be passed to F will be:\n\nFmap_dict = merge(DEFAULT_FMAP_OPTS, Fmap_opts) =       :θ_max => 2.0,           # CHANGED VALUE      :tolerance => 1e-5,      # CHANGED VALUE      :rtol => 1e-2,           # default      :atol => 1e-3,           # default      :pr => true,             # default )\n\nSee also: F, integrand_F\n\n\n\n\n\n","category":"function"},{"location":"WindowF/#GaPSE.integrand_F","page":"The F window function","title":"GaPSE.integrand_F","text":"integrand_F(θ, θ_1, x, μ, θ_max; tolerance=1e-8) :: Float64\n\nReturn the integrand of the function F(xmu theta_mathrmmax), i.e the  function f(xmu theta theta_1 theta_mathrmmax):\n\nbeginsplit\nf(xmu theta theta_1 theta_mathrmmax) = \n     Thetaleft( frac\n        x cos theta + cos theta_1sqrtx^1+2+2xmu - \n        cos(theta_mathrmmax) \n        right) \n     times  Theta(mu-cos(theta+theta_1))   times \n     quad Theta(cos(theta - theta_1)-mu)  times \n    frac4pi sinthetasintheta_1\n        sqrt(sinthetasintheta_1)^2-(costhetacostheta_1-mu)^2\nendsplit\n\nbeginequation\nF(xmu theta_mathrmmax) = int_0^theta_mathrmmax \n        mathrmdtheta_1 int_0^pi mathrmd theta \n         f(xmu theta theta_1 theta_mathrmmax)\nendequation\n\ntolerance is a parameter needed in case of small negative denominator: the Heaviside theta function mathematically prevent that  mathrmden=(sinthetasintheta_1)^2-(costhetacostheta_1-mu)^2 becomes negative, but computationally might happen that mathrmden results as a very small negative number (for instance -1.2368946523-18); in this case tolerance solve the problem, returning 0 if 0-mathrmden mathrmtolerance\n\nSee also: F, F_map\n\n\n\n\n\n","category":"function"},{"location":"WindowF/#GaPSE.WindowF","page":"The F window function","title":"GaPSE.WindowF","text":"WindowF(\n    xs::Vector{Float64}\n    μs::Vector{Float64}\n    Fs::Matrix{Float64}\n    )\n\nStruct containing xs, μs and Fs values of the window function F(x μ). xs and μs are 1D vectors containing each value only once, while  Fs values are contained in a matrix of size (length(xs), length(μs)), so:\n\nalong a fixed column the changing value is x\nalong a fixed row the changing value is μ\n\n\n\n\n\n","category":"type"},{"location":"WindowF/#GaPSE.spline_F","page":"The F window function","title":"GaPSE.spline_F","text":" spline_F(x, μ, str::WindowF)) :: Float64\n\nReturn the 2-dim spline value of F in the given (x,μ), where F is defined in the input WindowF. The spline is obtained through the interpolate function of the  GridInterpolations Julia package.\n\n\n\n\n\n","category":"function"},{"location":"Cosmology/","page":"Cosmology Struct","title":"Cosmology Struct","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"Cosmology/#Cosmology-struct","page":"Cosmology Struct","title":"Cosmology struct","text":"","category":"section"},{"location":"Cosmology/","page":"Cosmology Struct","title":"Cosmology Struct","text":"GaPSE.func_ℛ\nGaPSE.Cosmology\nGaPSE.Point  ","category":"page"},{"location":"Cosmology/#GaPSE.func_ℛ","page":"Cosmology Struct","title":"GaPSE.func_ℛ","text":" func_ℛ(s, ℋ; s_lim=0.01, ℋ_0 = ℋ0)\n\nReturn the following value:\n\nmathrmfunc_ℛ(s scrH)=\nbegincases\n1 - frac1scrH  s  \n    quad s  s_mathrmlim\n1 - frac1scrH_0  s_mathrmlim   \n     quad quad 0 leq s leq s_mathrmlim\nendcases\n\n\n\n\n\n","category":"function"},{"location":"Cosmology/#GaPSE.Cosmology","page":"Cosmology Struct","title":"GaPSE.Cosmology","text":" Cosmology(\n      IPS::InputPS\n      params::CosmoParams\n      tools::IPSTools\n      windowF::WindowF\n\n      z_of_s::Dierckx.Spline1D\n      D_of_s::Dierckx.Spline1D\n      f_of_s::Dierckx.Spline1D\n      ℋ_of_s::Dierckx.Spline1D\n      ℛ_of_s::Dierckx.Spline1D\n\n      s_of_z::Dierckx.Spline1D\n\n      z_eff::Float64\n      s_min::Float64\n      s_max::Float64\n      s_eff::Float64\n\n      volume::Float64\n\n      file_data::String\n      file_ips::String\n      file_windowF::String\n      )\n\nStruct that contains all the information that may be used for the  Correlation Function computations.\n\nArguments\n\nIPS::InputPS : the matter Input Power Spectrum of the Universe we are focusiong on.\nparams::CosmoParams : options and parameters decided for this Cosmology.\ntools::IPSTools : all the functions and integrals depending on the Input PS.\nwindowF::WindowF : the window function F, defined as:\n   beginsplit\n   F(xmu theta_mathrmmax) =  4pi \n   int_0^theta_mathrmmax mathrmdtheta_1 int_0^pi mathrmd theta  \n    Thetaleft(frac\n        x cos theta + cos theta_1sqrtx^1+2+2xmu - \n        cos(theta_mathrmmax) \n        right) \n    Theta(mu-cos(theta+theta_1)) \n   Theta(cos(theta - theta_1)-mu) \n   fracsinthetasintheta_1\n        sqrt(sinthetasintheta_1)^2-(costhetacostheta_1-mu)^2\n   endsplit\nz_of_s, D_of_s, f_of_s, ℋ_of_s, ℛ_of_s ::Dierckx.Spline1D : splines that returns the value of z, D, f, ℋ and ℛ (respectively) corresponding to an input comoving distance s. These splines are obtained from the data stored by BackgroundData applied to the input background data file.\ns_of_z ::Dierckx.Spline1D : splines that returns the value of the comoving distance s corresponding to an input redshift z. Also this spline is obtained from the data stored by  BackgroundData applied to the input background data file.\nz_eff::Float64 : effective redshift of this survey; its value is obtained through the function func_z_eff, with inputs the s_min, s_max and z_of_s here stored.\ns_min::Float64 and s_max::Float64 : the minimum and maximum comoving distances of the survey considered; they are the corresponding comoving distance to the chosen minimum and maximum redshifts z_min and z_max, stored in the input CosmoParams.\ns_eff::Float64 : the corresponding comoving distance to the computed effective  redshifts z_eff.\nvolume::Float64 : volume of this survey. It is computed applying the function V_survey with inputs s_min, s_max here stored and the θ_max in the input CosmoParams.\nfile_data, file_ips, file_windowF::String : the file names used for this Cosmology.\n\nConstructors\n\nCosmology(      params::CosmoParams,      file_data::String,      file_ips::String,      file_windowF::String,      file_Is::Union{String,Nothing} = nothing;      names_bg = NAMES_BACKGROUND)\n\nparams::CosmoParams : parameters to be used for this Cosmology. See the docstring of CosmoParams for more information on the possible inputs.\nfile_data::String : file containing all the background data; it is expected that such file is a background output of the CLASS program (link: https://github.com/lesgourg/class_public). It is managed through BackgroundData.\nfile_ips::String : file containing the Input Power Spectrum; it is expected that such file is a power spectrum output of the CLASS program (link: https://github.com/lesgourg/class_public). It is managed through InputPS.\nfile_windowF::String : file containing a map of the window function F. This file is managed through WindowF, and can be produced with F_map; see their docstrings for more information.\nfile_Is::Union{String,Nothing} = nothing : if you want to given in input manually all the I_ell^n integrals, you can set as input the file containing them. It is expected that they are ordered in colums with the following order: s  I00  I20  I40  I02  I22  I31  I11  I13  I04_tilde. If nothing is passed (recommended), they are manually calculated from the Input Power Spectrum.\nnames = NAMES_BACKGROUND : the column names of the file_data. If the colum order change from the default one NAMES_BACKGROUND, you must set as input the vector of string with the correct one, with the SAME names. They are, with the default order:\n[\"z\", \"proper time [Gyr]\", \"conf. time [Mpc]\", \"H [1/Mpc]\", \"comov. dist.\", \"ang.diam.dist.\", \"lum. dist.\", \"comov.snd.hrz.\", \"(.)rhog\", \"(.)rhob\", \"(.)rhocdm\", \"(.)rholambda\", \"(.)rhour\", \"(.)rhocrit\", \"gr.fac. D\", \"gr.fac. f\"]  \n\nSee also:  InputPS, CosmoParams, IPSTools, BackgroundData, WindowF, F_map, func_z_eff, V_survey\n\n\n\n\n\n","category":"type"},{"location":"Cosmology/#GaPSE.Point","page":"Cosmology Struct","title":"GaPSE.Point","text":" Point(\n      z::Float64\n      #conftime::Float64\n      comdist::Float64\n      #angdist::Float64\n      #lumdist::Float64\n      D::Float64\n      f::Float64\n      ℋ::Float64\n      #ℋ_p::Float64\n      ℛ::Float64\n      a::Float64)\n\nA point in the Universe, placed at redshift z from us. It contains all the relevant cosmological information at that redshift.\n\nConstructors\n\nPoint(s, cosmo::Cosmology) : given a comoving distance s, extrapolate all  the data from the given input Cosmology.\n\nSee also: Cosmology\n\n\n\n\n\n","category":"type"},{"location":"CosmoParams/","page":"Cosmology Parameters","title":"Cosmology Parameters","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"CosmoParams/#The-Cosmology-Parameters","page":"Cosmology Parameters","title":"The Cosmology Parameters","text":"","category":"section"},{"location":"CosmoParams/","page":"Cosmology Parameters","title":"Cosmology Parameters","text":"GaPSE.DEFAULT_IPS_OPTS\nGaPSE.DEFAULT_IPSTOOLS_OPTS\nGaPSE.CosmoParams","category":"page"},{"location":"CosmoParams/#GaPSE.DEFAULT_IPS_OPTS","page":"Cosmology Parameters","title":"GaPSE.DEFAULT_IPS_OPTS","text":" const DEFAULT_IPS_OPTS = Dict(\n      :fit_left_min => 1e-6::Float64, \n      :fit_left_max => 3e-6::Float64,\n      :fit_right_min => 1e1::Float64, \n      :fit_right_max => 2e1::Float64,\n      )\n\nThe default values to be stored in CosmoParams concerning the  Input Power Spectrum. In the Cosmology that will have such CosmoParams as input, they will be used in its InputPS.\n\nSee also: CosmoParams, Cosmology, InputPS\n\n\n\n\n\n","category":"constant"},{"location":"CosmoParams/#GaPSE.DEFAULT_IPSTOOLS_OPTS","page":"Cosmology Parameters","title":"GaPSE.DEFAULT_IPSTOOLS_OPTS","text":" const DEFAULT_IPSTOOLS_OPTS = Dict(\n      :N => 1024::Integer,\n      :fit_min => 0.05::Float64,\n      :fit_max => 0.5::Float64,\n      :con => true::Bool,\n      :k_min => 1e-6::Float64,\n      :k_max => 10.0::Float64,\n )\n\nThe default values to be stored in CosmoParams concerning the  Input Power Spectrum Tools. In the Cosmology that will have such CosmoParams as input, they will be used in its IPSTools.\n\nSee also: CosmoParams, Cosmology, IPSTools\n\n\n\n\n\n","category":"constant"},{"location":"CosmoParams/#GaPSE.CosmoParams","page":"Cosmology Parameters","title":"GaPSE.CosmoParams","text":" CosmoParams(\n      z_min::Float64\n      z_max::Float64\n      θ_max::Float64\n\n      Ω_b::Float64\n      Ω_cdm::Float64\n      Ω_M0::Float64\n      h_0::Float64\n\n      s_lim::Float64\n\n      IPS::Dict{Symbol,T1} where {T1}\n      IPSTools::Dict{Symbol,T2} where {T2}\n )\n\nStruct that contains all the parameters and options that are  matter of concerns for the Cosmology we are interested in.\n\nArguments\n\nz_min::Float64 and z_max::Float64 : the minimum and maximum redshifts of the survey we want to study.\nθ_max::Float64 : Angular maximum value of the survey. It is implicitly assumed an azimutal simmetry of the survey.\nΩ_b::Float64, Ω_cdm::Float64 and Ω_M0::Float64 : barionic, cold-dark-matter and total matter density parameters.\nh_0::Float64 : today's Hubble adimensional parameter (H_0 = h_0 * 100 km/(s * Mpc)).\ns_lim::Float64 : the lower-bound value for the function func_ℛ; it is necessary, because ℛ blows up for s rightarrow 0^+. Consequently, if the func_ℛ input value is  0 ≤ s < s_lim, the returned value is always func_ℛ(s_lim).\nIPS::Dict{Symbol,T1} where {T1} : dictionary concerning all the options that should be  passed to InputPS in the contruction of a Cosmology. The allowed keys, with their default values, are stored in  DEFAULT_IPS_OPTS, and are the following:\n:fit_left_min => 1e-6 and :fit_left_max => 3e-6 : the limits (min and max) where the PS must be fitted with a (pure) power law, for small wavenumbers. \n:fit_right_min => 1e1 and :fit_right_max => 2e1 : the limits (min and max) where the PS must be fitted with a (pure) power law, for high wavenumbers. \nIPSTools::Dict{Symbol,T2} where {T2} : dictionary concerning all the options that should be  passed to IPSTools in the contruction of a Cosmology. The allowed keys, with their default values, are stored in  DEFAULT_IPSTOOLS_OPTS, and are the following:\n:fit_min => 0.05 and :fit_max => 0.5 : the limits (min and max)  where the integral I_ell^n in Cosmology must be fitted with a power law,  for small distances. This operation is necessary, because xicalc, in this context,  gives wrong results for too small input distance s; nevertheless, all these I_ell^n  integrals have fixed power-law trends for s rightarrow 0, so this approach gives good results.\n:N => 1024 : number of points to be used in the Sperical Bessel Fourier Transform made by xicalc in IPSTools.\n:k_min => 1e-6 and :k_max => 10.0 : extremes of integration for the σ_i integrals in IPSTools.\n:con => true : do you want that the fit of all the I_ell^n in IPSTools for  the LEFT edge is not a simple power-law y = f(x) = b  x^s, but also consider  a constant a, such that y = f(x) = a + b  x^s?\n\nConstructors\n\nCosmoParams(z_min, z_max, θ_max;           Ω_b = 0.0489, Ω_cdm = 0.251020, h_0 = 0.70, s_lim = 1e-2,           IPS_opts::Dict = Dict{Symbol,Any}(),           IPSTools_opts::Dict = Dict{Symbol,Any}()      ) The associations are trivials, with Ω_M0 = Ω_cdm + Ω_b. For the two dictionary, you may pass only the key and the value you are interested in, and all the other default ones will be considered. For example, if you set:\n\nIPSTools_opts = Dict(:N => 150, :con => false, :k_max => 30.0)\n\nthen the dictionary with all the options that will be passed to IPSTools will be:\n\nIPSTools = merge(DEFAULT_IPSTOOLS_OPTS, IPSTools_opts) =       :fit_min => 0.05,   # default      :fit_max => 0.5,    # default      :N => 150,          # CHANGED VALUE      :con => false,      # CHANGED VALUE      :k_min => 1e-6,     # default      :k_max => 30.0,     # CHANGED VALUE )\n\nand similar for IPS_opts.\n\nSee also: Cosmology, IPSTools,  InputPS,  func_ℛ, DEFAULT_IPSTOOLS_OPTS, DEFAULT_IPS_OPTS, check_compatible_dicts\n\n\n\n\n\n","category":"type"},{"location":"XiMultipoles/","page":"Xi Multipoles","title":"Xi Multipoles","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"XiMultipoles/#The-ξ-multipoles-computation","page":"Xi Multipoles","title":"The ξ multipoles computation","text":"","category":"section"},{"location":"XiMultipoles/","page":"Xi Multipoles","title":"Xi Multipoles","text":"GaPSE.integrand_ξ_multipole\nGaPSE.ξ_multipole\nGaPSE.map_ξ_multipole\nGaPSE.print_map_ξ_multipole","category":"page"},{"location":"XiMultipoles/#GaPSE.integrand_ξ_multipole","page":"Xi Multipoles","title":"GaPSE.integrand_ξ_multipole","text":" integrand_ξ_multipole(s1, s, μ, effect::Function, cosmo::Cosmology;\n      L::Integer = 0, \n      use_windows::Bool = true, \n      kwargs...) ::Float64\n\n integrand_ξ_multipole(s1, s, μ, effect::String, cosmo::Cosmology; \n      L::Integer = 0, \n      use_windows::Bool = true, \n      kwargs...) ::Float64\n\nReturn the integrand on mu = hatmathbfs_1 cdot hatmathbfs  of the of the chosen correlation function term, i.e. the following function f(s_1 s mu):\n\n     f(s_1 s mu) = xi (s_1 s_2 costheta) \n           mathcalL_L(mu)   phi(s_2)  Fleft(fracss_1 mu right)\n\nwhere y =  costheta = hatmathbfs_1 cdot hatmathbfs_2, s = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y and xi is the corresponding CF effect.\n\nIn the former method you have to pass as an input the effect function you want  to integrate, while in the (recommended) latter one it's necessary to specify the name of the CF term among the following: \n\nauto_doppler , auto_lensing , auto_localgp , auto_integratedgp , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\n\nto which correspond the following functions:\n\nξ_Doppler , ξ_Lensing , ξ_LocalGP , ξ_IntegratedGP , ξ_Lensing_Doppler , ξ_Doppler_Lensing , ξ_Doppler_LocalGP , ξ_LocalGP_Doppler , ξ_Doppler_IntegratedGP , ξ_IntegratedGP_Doppler , ξ_Lensing_LocalGP , ξ_LocalGP_Lensing , ξ_Lensing_IntegratedGP , ξ_IntegratedGP_Lensing , ξ_LocalGP_IntegratedGP , ξ_IntegratedGP_LocalGP ,\n\nThe window functions F(x mu) and phi(s) are calculated for the given Cosmology cosmo through the functions spline_F and ϕ respectivelly.\n\nIn case use_windows is set to false, the window functions phi and F are removed, i.e is returned the following function f^(s_1 s mu):\n\n     f^(s_1 s mu) = xi (s_1 s_2 costheta) \n           mathcalL_L(mu) \n\nThe function xi(s_1 s_2 costheta) is calculated from, depending on the value of effect:\n\neffect == auto_doppler => ξ_Doppler\neffect == auto_lensing => ξ_Lensing\neffect == auto_localgp => ξ_LocalGP\neffect == auto_integratedgp => ξ_IntegratedGP\neffect == doppler_lensing => ξ_Doppler_lensing\neffect == lensing_doppler => ξ_Lensing_Doppler\neffect == doppler_localgp => ξ_Doppler_LocalGP\neffect == localgp_doppler => ξ_LocalGP_Doppler\neffect == doppler_integratedgp => ξ_Doppler_IntegratedGP\neffect == integratedgp_doppler => ξ_IntegratedGP_Doppler\neffect == lensing_localgp => ξ_Lensing_LocalGP\neffect == localgp_lensing => ξ_LocalGP_Lensing\neffect == lensing_integratedgp => ξ_Lensing_IntegratedGP\neffect == integratedgp_lensing => ξ_IntegratedGP_Lensing\neffect == localgp_integratedgp => ξ_LocalGP_IntegratedGP\neffect == integratedgp_localgp => ξ_IntegratedGP_LocalGP\n\nNote that these is an internal conversion of coordiate sistems from (s1, s, μ) to (s1, s2, y) thorugh the functions y and s2\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\nμ: the cosine between s1 and s where must be evaluated the integral\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nL::Integer = 0: order of the Legendre polynomial to be used\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and F\nkwargs... : other keyword arguments that will be passed to the selected  GR TPCF effect (ξ_Doppler, ξ_Lensing, ...)\n\nSee also: ξ_multipole, map_ξ_multipole, print_map_ξ_multipole, spline_F, ϕ, Cosmology,  y, s2, IMPLEMENTED_GR_EFFECTS\n\n\n\n\n\n","category":"function"},{"location":"XiMultipoles/#GaPSE.ξ_multipole","page":"Xi Multipoles","title":"GaPSE.ξ_multipole","text":" ξ_multipole(s1, s, effect::Function, cosmo::Cosmology; \n      L::Integer = 0, \n      enhancer::Float64 = 1e6,\n      use_windows::Bool = true,\n      μ_atol::Float64 = 1e-4,\n      μ_rtol::Float64 = 1e-1, \n      kwargs...) ::Float64\n\n ξ_multipole(s1, s, effect::String, cosmo::Cosmology; \n      L::Integer = 0, \n      enhancer::Float64 = 1e6,\n      use_windows::Bool = true,\n      μ_atol::Float64 = 1e-4,\n      μ_rtol::Float64 = 1e-1, \n      kwargs...) ::Float64\n\nEvaluate the multipole of order L of the chosen correlation function term,  through the integrand_ξ_multipole function.\n\nIn the former method you have to pass as an input the effect function you want  to integrate, while in the (recommended) latter one it's necessary to specify the name of the CF term among the following:\n\nauto_doppler , auto_lensing , auto_localgp , auto_integratedgp , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\n\nto which correspond the following functions:\n\nξ_Doppler , ξ_Lensing , ξ_LocalGP , ξ_IntegratedGP , ξ_Lensing_Doppler , ξ_Doppler_Lensing , ξ_Doppler_LocalGP , ξ_LocalGP_Doppler , ξ_Doppler_IntegratedGP , ξ_IntegratedGP_Doppler , ξ_Lensing_LocalGP , ξ_LocalGP_Lensing , ξ_Lensing_IntegratedGP , ξ_IntegratedGP_Lensing , ξ_LocalGP_IntegratedGP , ξ_IntegratedGP_LocalGP ,\n\nThe function evaluated is then the following:\n\nxi_L(s_1 s mu) = frac2 L + 12 int_-1^+1 mathrmdmu  \n    xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\nbegincases  \n    phi(s_2)  Fleft(fracss_1 mu right) \n        quad mathrmuse_windows == true\n    1 quad mathrmuse_windows == false\nendcases\n\nwhere y =  costheta = hatmathbfs_1  cdot hatmathbfs_2 and xi is the chosen CF effect. \n\nThe window functions F(x mu) and phi(s) are calculated for the given Cosmology cosmo through the functions spline_F and ϕ respectivelly.\n\nThe function xi(s_1 s_2 costheta) is calculated from, depending on the value of effect:\n\neffect == auto_doppler => ξ_Doppler\neffect == auto_lensing => ξ_Lensing\neffect == auto_localgp => ξ_LocalGP\neffect == auto_integratedgp => ξ_IntegratedGP\neffect == doppler_lensing => ξ_Doppler_lensing\neffect == lensing_doppler => ξ_Lensing_Doppler\neffect == doppler_localgp => ξ_Doppler_LocalGP\neffect == localgp_doppler => ξ_LocalGP_Doppler\neffect == doppler_integratedgp => ξ_Doppler_IntegratedGP\neffect == integratedgp_doppler => ξ_IntegratedGP_Doppler\neffect == lensing_localgp => ξ_Lensing_LocalGP\neffect == localgp_lensing => ξ_LocalGP_Lensing\neffect == lensing_integratedgp => ξ_Lensing_IntegratedGP\neffect == integratedgp_lensing => ξ_IntegratedGP_Lensing\neffect == localgp_integratedgp => ξ_LocalGP_IntegratedGP\neffect == integratedgp_localgp => ξ_IntegratedGP_LocalGP\n\nNote that these is an internal conversion of coordiate sistems from (s1, s, μ) to (s1, s2, y) thorugh the functions y and s2\n\nInputs\n\ns1: the comoving distance where must be evaluated the integral\ns: the comoving distance from s1 where must be evaluated the integral\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nL::Integer = 0: order of the Legendre polynomial to be used\nenhancer::Float64 = 1e6: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by enhancer.\nuse_windows::Bool = false: tells if the integrand must consider the two  window function phi and F\nμ_atol::Float64 = 1e-3 and μ_rtol::Float64 = 1e-3: absolute and relative tolerance to be passed to quadgk; it's recommended not to set μ_rtol < 1e-2 because of long time for evaluations\nkwargs... : other keyword arguments that will be passed to the selected  GR TPCF effect (ξ_Doppler, ξ_Lensing, ...)\n\nSee also: integrand_ξ_multipole,  map_ξ_multipole, print_map_ξ_multipole spline_F, ϕ, Cosmology,  y, s2, IMPLEMENTED_GR_EFFECTS\n\n\n\n\n\n","category":"function"},{"location":"XiMultipoles/#GaPSE.map_ξ_multipole","page":"Xi Multipoles","title":"GaPSE.map_ξ_multipole","text":" map_ξ_multipole(cosmo::Cosmology,\n      effect::Union{String,Function},\n      v_ss = nothing;\n      s1 = nothing,\n      pr::Bool = true,\n      N_log::Integer = 1000,\n      L::Integer = 0,\n      kwargs... ) ::Tuple{Vector{Float64}, Vector{Float64}}\n\nEvaluate the multipole of order L of the chosen correlation function term,  through the ξ_multipole function, for all the s values stored inside v_ss. If v_ss = nothing, it is set v_ss = 10 .^ range(0, 3, length = N_log). If s1 = nothing, it is set s1 = cosmo.s_eff.\n\nThe function evaluated is then the following:\n\nxi_L(s_1 s mu) = frac2 L + 12 int_-1^+1 mathrmdmu  \n    xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\nbegincases  \n    phi(s_2)  Fleft(fracss_1 mu right) \n        quad mathrmuse_windows == true\n    1 quad mathrmuse_windows == false\nendcases\n\nwhere y =  costheta = hatmathbfs_1  cdot hatmathbfs_2 and xi is the chosen CF effect, for all the  comoving distances s inside v_ss. \n\nThe window functions F(x mu) and phi(s) are calculated for the given Cosmology cosmo through the functions spline_F and ϕ respectivelly.\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\neffect::Union{String,Function} : the GR effect TPCF you want to consider; you may specify the name of the effect as one of the following strings (recommended):\nauto_doppler , auto_lensing , auto_localgp , auto_integratedgp , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\nor directly the name of the function among the following: \nξ_Doppler , ξ_Lensing , ξ_LocalGP , ξ_IntegratedGP , ξ_Lensing_Doppler , ξ_Doppler_Lensing , ξ_Doppler_LocalGP , ξ_LocalGP_Doppler , ξ_Doppler_IntegratedGP , ξ_IntegratedGP_Doppler , ξ_Lensing_LocalGP , ξ_LocalGP_Lensing , ξ_Lensing_IntegratedGP , ξ_IntegratedGP_Lensing , ξ_LocalGP_IntegratedGP , ξ_IntegratedGP_LocalGP ,\n`v_ss : vector/range of s values where the function must be evaluated; if v_ss = nothing,  it is set v_ss = 10 .^ range(0, 3, length = N_log). This is why it is returned  also the vector of the \"input\" values.\n\nOptional arguments\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input Cosmology.\nL::Integer = 0: order of the Legendre polynomial to be used\npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nN_log::Integer = 1000 : number of points to be used in the default logaritmically-spaced  range for v_ss, i.e. range(0, 3, N_log); it is ignored if v_ss ≠ nothing \nkwargs... : other keyword arguments that will be passed to ξ_multipole\n\nReturns\n\nA Tuple{Vector{Float64}, Vector{Flaot64}}, which has as first element the v_ss vector and as second one the corresponding ξ value evaluated.\n\nSee also: integrand_ξ_multipole, ξ_multipole, print_map_ξ_multipole, spline_F, ϕ, Cosmology,  y, s2, IMPLEMENTED_GR_EFFECTS\n\n\n\n\n\n","category":"function"},{"location":"XiMultipoles/#GaPSE.print_map_ξ_multipole","page":"Xi Multipoles","title":"GaPSE.print_map_ξ_multipole","text":" print_map_ξ_multipole(\n      cosmo::Cosmology,\n      out::String,\n      effect::Union{String,Function},\n      v_ss = nothing;\n      s1 = nothing,\n      kwargs...)\n\nEvaluate the multipole of order L of the chosen correlation function term,  through the ξ_multipole function, for all the s values stored inside v_ss, and print the results (with all the options used) in a file named out. If v_ss = nothing, it is set v_ss = 10 .^ range(0, 3, length = N_log). If s1 = nothing, it is set s1 = cosmo.s_eff.\n\nThe function evaluated is then the following:\n\nxi_L(s_1 s mu) = frac2 L + 12 int_-1^+1 mathrmdmu  \n    xi (s_1 s_2 costheta)  mathcalL_L(mu)   times\nbegincases  \n    phi(s_2)  Fleft(fracss_1 mu right) \n        quad mathrmuse_windows == true\n    1 quad mathrmuse_windows == false\nendcases\n\nwhere y =  costheta = hatmathbfs_1  cdot hatmathbfs_2 and xi is the chosen CF effect, for all the  comoving distances s inside v_ss. \n\nThe window functions F(x mu) and phi(s) are calculated for the given Cosmology cosmo through the functions spline_F and ϕ respectivelly.\n\nInputs\n\ncosmo::Cosmology : cosmology to be used in this computation\neffect::Union{String,Function} : the GR effect TPCF you want to consider; you may specify the name of the effect as one of the following strings (recommended):\nauto_doppler , auto_lensing , auto_localgp , auto_integratedgp , lensing_doppler , doppler_lensing , doppler_localgp , localgp_doppler , doppler_integratedgp , integratedgp_doppler , lensing_localgp , localgp_lensing , lensing_integratedgp , integratedgp_lensing , localgp_integratedgp , integratedgp_localgp ,\nor directly the name of the function among the following: \nξ_Doppler , ξ_Lensing , ξ_LocalGP , ξ_IntegratedGP , ξ_Lensing_Doppler , ξ_Doppler_Lensing , ξ_Doppler_LocalGP , ξ_LocalGP_Doppler , ξ_Doppler_IntegratedGP , ξ_IntegratedGP_Doppler , ξ_Lensing_LocalGP , ξ_LocalGP_Lensing , ξ_Lensing_IntegratedGP , ξ_IntegratedGP_Lensing , ξ_LocalGP_IntegratedGP , ξ_IntegratedGP_LocalGP ,\nout::String : name of the file where the results must be stored.\n`v_ss : vector/range of s values where the function must be evaluated; if v_ss = nothing,  it is set v_ss = 10 .^ range(0, 3, length = N_log).\n\nOptional arguments\n\ns1 = nothing : comoving distance from the observer where the TPCF should be evaluated; if s1 = nothing, it is automatically set s1 = cosmo.s_eff from the given input Cosmology.\nkwargs... : other keyword arguments that will be passed to map_ξ_multipole\n\nSee also: integrand_ξ_multipole, ξ_multipole, map_ξ_multipole,  spline_F, ϕ, Cosmology,  y, s2, IMPLEMENTED_GR_EFFECTS\n\n\n\n\n\n","category":"function"},{"location":"CrossCorrelations/","page":"CrossCorrelations","title":"CrossCorrelations","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"CrossCorrelations/#Cross-Correlation-functions","page":"CrossCorrelations","title":"Cross-Correlation functions","text":"","category":"section"},{"location":"CrossCorrelations/","page":"CrossCorrelations","title":"CrossCorrelations","text":"GaPSE.ξ_Lensing_Doppler\nGaPSE.ξ_Doppler_Lensing\nGaPSE.ξ_Doppler_LocalGP\nGaPSE.ξ_LocalGP_Doppler\nGaPSE.ξ_Doppler_IntegratedGP\nGaPSE.ξ_IntegratedGP_Doppler\nGaPSE.ξ_Lensing_LocalGP\nGaPSE.ξ_LocalGP_Lensing,\nGaPSE.ξ_Lensing_IntegratedGP\nGaPSE.ξ_IntegratedGP_Lensing\nGaPSE.ξ_LocalGP_IntegratedGP\nGaPSE.ξ_IntegratedGP_LocalGP","category":"page"},{"location":"CrossCorrelations/#GaPSE.ξ_Lensing_Doppler","page":"CrossCorrelations","title":"GaPSE.ξ_Lensing_Doppler","text":" ξ_Lensing_Doppler(s1, s2, y, cosmo::Cosmology;\n      en::Float64 = 1e6, N_χs::Integer = 100):: Float64\n\nReturn the Lensing-Doppler cross-correlation function  xi^v_parallelkappa (s_1 s_2 costheta), defined as follows:\n\nxi^v_parallelkappa (s_1 s_2 costheta) = \n     mathcalH_0^2 Omega_M0 D(s_2) f(s_2) mathcalH(s_2) mathcalR(s_2) \n     int_0^s_1 mathrmd chi_1 \n     frac D(chi_1) (chi_1 - s_1) a(chi_1) s_1 \n     left(\n          J_00 I^0_0(Deltachi_1) + J_02 I^0_2(Deltachi_1) \n          + J_04 I^0_4(Deltachi_1) + J_20 I^2_0(Deltachi_1)\n     right)\n\nwhere mathcalH = a H,  Deltachi_1= sqrtchi_1^2 + s_2^2 - 2 chi_1 s_2 costheta,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2)  and the J coefficients are given by:\n\nbeginalign*\n     J_00  = frac115(chi_1^2 y + chi_1(4 y^2 - 3) s_2 - 2 y s_2^2) \n     J_02  = frac142 Deltachi_1^2 \n          (4 chi_1^4 y + 4 chi_1^3 (2 y^2 - 3) s_2 + chi_1^2 y (11 - 23 y^2) s_2^2 + \n          chi_1 (23 y^2 - 3) s_2^3 - 8 y s_2^4) \n     J_04  = frac170 Deltachi_1^2\n          (2 chi_1^4 y + 2 chi_1^3 (2y^2 - 3) s_2 - chi_1^2 y (y^2 + 5) s_2^2 + \n          chi_1 (y^2 + 9) s_2^3 - 4 y s_2^4) \n     J_20  = y Deltachi_1^2\nendalign*\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_Lensing_Doppler.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nΔχ_min::Float64 = 1e-6 : when Deltachi = sqrtchi_1^2 + chi_2^2 - 2  chi_1 chi_2 y to 0^+, some I_ell^n term diverges, but the overall parenthesis has a known limit:\n   lim_chito0^+ (J_00  I^0_0(chi) + J_02  I^0_2(chi) + \n        J_31  I^3_1(chi) + J_22  I^2_2(chi)) = \n        frac415  (5  sigma_2 + frac23  σ_0 s_1^2  chi_2^2)\nSo, when it happens that chi  Deltachi_mathrmmin, the function considers this limit as the result of the parenthesis instead of calculating it in the normal way; it prevents computational divergences.\nN_χs::Integer = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s1) (for χ2); it has been checked that with N_χs ≥ 50 the result is stable.\n\nSee also: integrand_ξ_Lensing_Doppler, int_on_mu_Lensing_Doppler integral_on_mu, ξ_multipole\n\n\n\n\n\n","category":"function"},{"location":"CrossCorrelations/#GaPSE.ξ_Doppler_LocalGP","page":"CrossCorrelations","title":"GaPSE.ξ_Doppler_LocalGP","text":" ξ_Doppler_LocalGP(P1::Point, P2::Point, y, cosmo::Cosmology) :: Float64\n\nReturn the Doppler-LocalGP cross-correlation function, defined as follows:\n\nxi^v_parallelphi (s_1 s_2 costheta) = \n     frac32 a(s_2) mathcalH(s_1) f(s_1) D(s_1)\n     mathcalR(s_1) mathcalH_0^2 Omega_M0 D(s_2)\n     (1 + mathcalR(s_2)) (s_2costheta - s_1) s^2 I^3_1(s)\n\nwhere mathcalH = a H, y = costheta = hatmathbfs_1 cdot hatmathbfs_2 and :\n\nI^n_l(s) = int_0^infty fracmathrmdq2pi^2 q^2  P(q)  fracj_l(qs)(q s)^n\n\nInputs\n\nP1::Point and P2::Point: Point where the CF has to be calculated; they contain all the  data of interest needed for this calculus (comoving distance, growth factor and so on)\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nSee also: Point, Cosmology\n\n\n\n\n\n","category":"function"},{"location":"CrossCorrelations/#GaPSE.ξ_Doppler_IntegratedGP","page":"CrossCorrelations","title":"GaPSE.ξ_Doppler_IntegratedGP","text":" ξ_Doppler_IntegratedGP(s1, s2, y, cosmo::Cosmology;\n      en::Float64 = 1e6, N_χs::Integer = 100):: Float64\n\nReturn the Doppler-LocalGP cross-correlation function  xi^v_parallelintphi (s_1 s_2 costheta), defined as follows:\n\nxi^v_parallelintphi (s_1 s_2 costheta) = \n     3 mathcalH(s_1) f(s_1) D(s_1) mathcalH_0^2 Omega_M0 mathcalR(s_1) \n     int_0^s_2 mathrmdchi_2   J_31   I^3_1(chi)\n\nwhere mathcalH = a H,  chi = sqrts_1^2 + chi_2^2 - 2 s_1 chi_2 costheta,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2)  and:\n\nJ_31 = \n     fracD(chi_2) (s_1 - chi_2 costheta)a(chi_2) chi^2 \n     left(\n          - frac1s_2 + mathcalR(s_2) mathcalH(chi_2) (f(chi_2) - 1)\n     right)\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_Doppler_IntegratedGP.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_χs::Integer = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s1) (for χ2); it has been checked that with N_χs ≥ 50 the result is stable.\n\nSee also: integrand_ξ_Doppler_IntegratedGP, int_on_mu_Doppler_IntegratedGP integral_on_mu, ξ_multipole\n\n\n\n\n\n","category":"function"},{"location":"CrossCorrelations/#GaPSE.ξ_Lensing_LocalGP","page":"CrossCorrelations","title":"GaPSE.ξ_Lensing_LocalGP","text":" ξ_Lensing_LocalGP(s1, s2, y, cosmo::Cosmology;\n      en::Float64 = 1e6, N_χs::Integer = 100):: Float64\n\nReturn the Lensing-LocalGP cross-correlation function  xi^kappa phi (s_1 s_2 costheta), defined as follows:\n\nxi^kappa phi (s_1 s_2 costheta) = \n     frac\n          9 mathcalH_0^4 Omega_M0^2 D(s_2) (1 + mathcalR(s_2)) s_2\n     4 a(s_2) s_1 \n     int_0^s_1 mathrmdchi_1 fracD(chi_1)(s_1 - chi_1) a(chi_1)\n     left( J_31 I^3_1(Deltachi_1) +  J_22 I^2_2(Deltachi_1) right)\n\nwhere mathcalH = a H,  Deltachi_1 = sqrtchi_1^2 + s_2^2 - 2 chi_1 s_2costheta,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2)  and the J coefficients are given by \n\nbeginalign*\n     J_31  = -2 y Deltachi_1^2 \n     J_22  = chi_1 s_2 (1 - y^2)\nendalign*\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_Lensing_LocalGP.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_χs::Integer = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s1) (for χ2); it has been checked that with N_χs ≥ 50 the result is stable.\n\nSee also: integrand_ξ_Lensing_LocalGP, int_on_mu_Lensing_LocalGP integral_on_mu, ξ_multipole\n\n\n\n\n\n","category":"function"},{"location":"CrossCorrelations/#GaPSE.ξ_LocalGP_IntegratedGP","page":"CrossCorrelations","title":"GaPSE.ξ_LocalGP_IntegratedGP","text":" ξ_LocalGP_IntegratedGP(s1, s2, y, cosmo::Cosmology;\n      en::Float64 = 1e6, N_χs::Integer = 100):: Float64\n\nReturn the LocalGP-IntegratedGP cross-correlation function  xi^v_parallelint phi (s_1 s_2 costheta), defined as follows:\n\nxi^v_parallelint phi (s_1 s_2 costheta) = \n     frac9 mathcalH_0^4 Omega_M0^2 D(s_1) (mathcalR(s_1) +1)2 a(s_1) \n     int_0^s_2 mathrmdchi_2 fracD(chi_2) Deltachi_2^4 a(chi_2)\n     left(\n          mathcalH(chi_2)( f(chi_2) - 1) mathcalR(s_2) - frac1s_2\n     right) tildeI^4_0(Deltachi_2)\n\nwhere mathcalH = a H,  Deltachi_2 = sqrts_1^2 + chi_2^2 - 2 s_1 chi_2 costheta,  y = costheta = hatmathbfs_1 cdot hatmathbfs_2).\n\nThe computation is made applying trapz (see the  Trapz Julia package) to the integrand function integrand_ξ_LocalGP_IntegratedGP.\n\nInputs\n\ns1 and s2: comovign distances where the function must be evaluated\ny: the cosine of the angle between the two points P1 and P2\ncosmo::Cosmology: cosmology to be used in this computation\n\nOptional arguments\n\nen::Float64 = 1e6: just a float number used in order to deal better  with small numbers;\nN_χs::Integer = 100: number of points to be used for sampling the integral along the ranges (0, s1) (for χ1) and (0, s1) (for χ2); it has been checked that with N_χs ≥ 50 the result is stable.\n\nSee also: integrand_ξ_LocalGP_IntegratedGP, int_on_mu_LocalGP_IntegratedGP integral_on_mu, ξ_multipole\n\n\n\n\n\n","category":"function"},{"location":"BackgroundData/","page":"Background Data","title":"Background Data","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"BackgroundData/#Background-functions","page":"Background Data","title":"Background functions","text":"","category":"section"},{"location":"BackgroundData/","page":"Background Data","title":"Background Data","text":"GaPSE.f0\nGaPSE.D0  \nGaPSE.ℋ0 \n\nGaPSE.BackgroundData","category":"page"},{"location":"BackgroundData/#GaPSE.f0","page":"Background Data","title":"GaPSE.f0","text":" const f0 :: Float64\n\nLinear growth rate at present time. Its value is equal to:\n\n     f_0 simeq 05126998572951\n\n\n\n\n\n","category":"constant"},{"location":"BackgroundData/#GaPSE.D0","page":"Background Data","title":"GaPSE.D0","text":" const D0 :: Float64\n\nLinear growth factor at present time. Its value is equal to:\n\n     D_0 = 10\n\n\n\n\n\n","category":"constant"},{"location":"BackgroundData/#GaPSE.ℋ0","page":"Background Data","title":"GaPSE.ℋ0","text":" const ℋ0 :: Float64\n\nComoving Hubble constant at present time. Its value is, in natural system (where the speed of light c=1):  mathcalH_0 simeq 3335641times10^-4  h_0^-1mathrmMpc\n\n\n\n\n\n","category":"constant"},{"location":"BackgroundData/#GaPSE.BackgroundData","page":"Background Data","title":"GaPSE.BackgroundData","text":" BackgroundData(\n      z::Vector{Float64}\n      conftime::Vector{Float64}\n      comdist::Vector{Float64}\n      angdist::Vector{Float64}\n      lumdist::Vector{Float64}\n      D::Vector{Float64}\n      f::Vector{Float64}\n      ℋ::Vector{Float64}\n      ℋ_p::Vector{Float64})\n\nStruct that contains all the relevant cosmological information for future computations. The data are stored with increasing distance values  (so the first ones are associated to z=0). It is internally used in Cosmology.\n\nArguments\n\nz::Vector{Float64} : redshifts (adimensionals).\nconftime::Vector{Float64} : conformal times, measured in [Mpc/h].\ncomdist::Vector{Float64} : comoving distances, measured in [Mpc/h].\nangdist::Vector{Float64} : angular diameter distances, measured in [Mpc/h].\nlumdist::Vector{Float64} : luminosity distances, measured in [Mpc/h].\nD::Vector{Float64} : linear growth factors, normalized to 1.0 at the present day (adimensional).\nf::Vector{Float64} : linear growth rates (adimensional).\nℋ::Vector{Float64} : comoving Hubble parameters, measured in [h/Mpc].\nℋ_p::Vector{Float64} : derivatives of the comoving Hubble parameter wrt the conformal time. It is here manually computed with the Dierckx function derivative.\n\nConstructors\n\nBackgroundData(file::String, z_max; names = NAMES_BACKGROUND, h = 0.7)\n\nfile::string : input file where the data are stored; it is expected that such file is a background output of the CLASS program (link: https://github.com/lesgourg/class_public)\nz_max : the maximum redhsift we are interested in our analysis. The constructor will store the data necessary for a study only in 0 < z < z_max, for optimisation purposes (More precisely, the maximum distance stored will be 3*z_max).\nnames = NAMES_BACKGROUND : the column names of the file. If the colum order change from the default one NAMES_BACKGROUND, you must set as input the vector of string with the correct one, with the SAME names. They are, with the default order:\n[\"z\", \"proper time [Gyr]\", \"conf. time [Mpc]\", \"H [1/Mpc]\", \"comov. dist.\", \"ang.diam.dist.\", \"lum. dist.\", \"comov.snd.hrz.\", \"(.)rhog\", \"(.)rhob\", \"(.)rhocdm\", \"(.)rholambda\", \"(.)rhour\", \"(.)rhocrit\", \"gr.fac. D\", \"gr.fac. f\"]\nh = 0.7 : the adimensional hubble constant. By default, CLASS background data are measured with it nuymerically expressed (so distances are measured in Mpc, for example), while this code works with h in the unit of measure (so distances are measured in Mpc/h, for example). Change this value to 1.0 if the input data do not have this issue, or to your value of interest  (0.67, 0.5, ...).\n\nSee also: CosmoParams, Cosmology\n\n\n\n\n\n","category":"type"},{"location":"CosmoUtils/","page":"Cosmology Utilities","title":"Cosmology Utilities","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"CosmoUtils/#The-Cosmology-Utilities","page":"Cosmology Utilities","title":"The Cosmology Utilities","text":"","category":"section"},{"location":"CosmoUtils/","page":"Cosmology Utilities","title":"Cosmology Utilities","text":"GaPSE.func_z_eff\nGaPSE.s\nGaPSE.μ\nGaPSE.s2\nGaPSE.y\nGaPSE.ϕ\nGaPSE.W\nGaPSE.V_survey\nGaPSE.A\nGaPSE.A_prime","category":"page"},{"location":"CosmoUtils/#GaPSE.func_z_eff","page":"Cosmology Utilities","title":"GaPSE.func_z_eff","text":" func_z_eff(s_min, s_max, z_of_s) :: Float64\n\nReturn the effective redshift z_mathrmeff, calcuated as follows:\n\nbeginsplit\nz_mathrmeff = \n    frac\n        int mathrmd^3mathbfs  phi^2(mathbfs)  z(s)\n     \n         int mathrmd^3mathbfs phi^2(mathbfs) \n       = frac\n          int_0^infty mathrmds   s^2  phi^2(s)  z(s) times\n          int_4pimathrmd^2hatmathbfs  W^2(hatmathbfs)\n      \n          int_0^infty mathrmds  s^2  phi^2(s)times\n          int_4pimathrmd^2hatmathbfs  W^2(hatmathbfs)\n       5pt\n      = frac\n          int_0^infty mathrmds   s^2  phi^2(s)  z(s)\n      \n          int_0^infty mathrmds  s^2  phi^2(s)\n       4pt\n      = frac3s_mathrmmax^3 - s_mathrmmin^3 \n          int_s_mathrmmin^s_mathrmmax mathrmds   s^2  z(s)\nendsplit\n\nwhere we have used our assuption on separability of the window function\n\n     phi(mathbfs) = phi(s)  W(hats)\n\nand their definitions.\n\nSee also: ϕ, W\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.s","page":"Cosmology Utilities","title":"GaPSE.s","text":" s(s1, s2, y) :: Float64\n\nReturn the value s = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\n\nSee also: μ, s2, y\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.μ","page":"Cosmology Utilities","title":"GaPSE.μ","text":" μ(s1, s2, y) :: Float64\n\nReturn the value mu=hatmathbfs_1cdothatmathbfs, defined as:\n\nmu = mu(s_1 s_2 y) = fracy  s_2 - s_1s(s_1 s_2 y) \nquad s(s_1 s_2 y) = sqrts_1^2 + s^2 - 2  s_1  s_2  y\n\nwith y=costheta=hatmathbfs_1cdothatmathbfs and where s is  obtained from the function s\n\nSee also: s, s2, y\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.s2","page":"Cosmology Utilities","title":"GaPSE.s2","text":" s2(s1, s, μ) :: Float64\n\nReturn the value s_2 = sqrts_1^2 + s^2 + 2  s_1  s  mu\n\nSee also: s, μ, y\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.y","page":"Cosmology Utilities","title":"GaPSE.y","text":" y(s1, s, μ) :: Float64\n\nReturn the value y=costheta, defined as:\n\ny = y(s_1 s mu) = fracmu  s + s_1s2(s_1 s mu) \nquad s_2 = sqrts_1^2 + s^2 + 2  s_1  s  mu\n\nwith mu=hatmathbfs_1cdothatmathbfs_2 and  where s_2 is btained from the function s2\n\nSee also: s, μ, s2\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.ϕ","page":"Cosmology Utilities","title":"GaPSE.ϕ","text":" ϕ(s, s_min, s_max) :: Float64\n\nRadial part of the survey window function. Return 1.0 if is true that s_mathrmmin  s  s_mathrmmax and 0.0 otherwise.\n\nIn this software we made the assuption that the survey window function can be separated into a radial and angular part, i.e.:\n\n     phi(mathbfs) = phi(s)  W(hats)\n\nSee also: W\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.W","page":"Cosmology Utilities","title":"GaPSE.W","text":" W(θ, θ_max) :: Float64\n\nAngular part of the survey window function. Return 1.0 if is true that 00 leq theta  theta_mathrmmax and 0.0 otherwise. It is implicitly assumed an azimutal simmetry of the survey.\n\nIn this software we made the assuption that the survey window function can be separated into a radial and angular part, i.e.:\n\n     phi(mathbfs) = phi(s)  W(hats)\n\nSee also: ϕ\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.V_survey","page":"Cosmology Utilities","title":"GaPSE.V_survey","text":" V_survey(s_min, s_max, θ_max) :: Float64\n\nReturn the volume of a survey with azimutal simmetry, i.e.:\n\nbeginsplit\n    V(s_mathrmmax s_mathrmmin theta_mathrmmax) =  C_mathrmup - C_mathrmdown + TC \n    C_mathrmup = fracpi3 s_mathrmmax^3  \n        (1 - costheta_mathrmmax)^2  (2 + costheta_mathrmmax) \n    C_mathrmdown = fracpi3 s_mathrmmin^3  \n        (1 - costheta_mathrmmax)^2  (2 + costheta_mathrmmax) \n    TC = fracpi3 (s_mathrmmax^2 + s_mathrmmin^2 + \n        s_mathrmmax s_mathrmmin)   (s_mathrmmax - s_mathrmmin) \n        costheta_mathrmmax sin^2theta_mathrmmax\nendsplit\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.A","page":"Cosmology Utilities","title":"GaPSE.A","text":" A(s_min, s_max, θ_max) :: Float64\n\nReturn the Power Spectrum multipole normalization coefficient A, i.e.:\n\n     A(s_mathrmmax s_mathrmmin theta_mathrmmax)= \n     frac\n          V(s_mathrmmax s_mathrmmin theta_mathrmmax)\n     4  pi^2\n\nwhere V(s_mathrmmax s_mathrmmin theta_mathrmmax) is the  survey volume.\n\nPay attention: this is NOT used for the normalization of PS, see instead A_prime\n\nSee also: V_survey\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.A_prime","page":"Cosmology Utilities","title":"GaPSE.A_prime","text":" A_prime :: Float64\n\nIt's the Power Spectrum multipole normalization coefficient A^, i.e.:\n\n     A^ = frac3  A (s_mathrmmax^3 - s_mathrmmin^3) = \n     frac14pi\n\nSee also: A, V_survey\n\n\n\n\n\n","category":"constant"},{"location":"OtherUtils/","page":"Other Utilities","title":"Other Utilities","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"OtherUtils/#Other-utilities","page":"Other Utilities","title":"Other utilities","text":"","category":"section"},{"location":"OtherUtils/","page":"Other Utilities","title":"Other Utilities","text":"GaPSE.check_compatible_dicts","category":"page"},{"location":"OtherUtils/#GaPSE.check_compatible_dicts","page":"Other Utilities","title":"GaPSE.check_compatible_dicts","text":"check_compatible_dicts(ref::Dict, b::Dict, name::String = \"NO-NAME\")\n\nCompare the field of two Dict and check if the second one (b) is \"compatible\" with the first one (ref), i.e.:\n\nchecks if each of the key in b is also a key of ref;\nfor each key of b:\nif typeof(ref[key]) <: Real and !(typeof(ref[k]) <: Union{Bool, Integer}), checks that typeof(b[k]) <: Real && typeof(b[k]) ≠ Bool\notherwise, checks that typeof(b[k]) == typeof(ref[k])\n\nIf someone of the check mentioned is false, raise an AssertionError, otherwise return nothing.  The string name is only used inside the AssertionError messages for the correct name of the input b dictionary.\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/","page":"Power Spectrum Multipoles","title":"Power Spectrum Multipoles","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"PowerSpectrum/#The-Power-Spectrum-multipole-computation","page":"Power Spectrum Multipoles","title":"The Power Spectrum multipole computation","text":"","category":"section"},{"location":"PowerSpectrum/","page":"Power Spectrum Multipoles","title":"Power Spectrum Multipoles","text":"GaPSE.PS_multipole\nGaPSE.print_PS_multipole","category":"page"},{"location":"PowerSpectrum/#GaPSE.PS_multipole","page":"Power Spectrum Multipoles","title":"GaPSE.PS_multipole","text":" PS_multipole(input::String; kwargs...\n      ) ::Tuple{Vector{Float64}, Vector{Float64}}\n\n PS_multipole(ss, fs;\n      int_s_min::Float64=1e-1, int_s_max::Float64=1e3,\n      epl::Bool=true,\n      N_left::Integer=12, N_right::Integer=12,\n      p0_left=[-2.0, 1.0], p0_right=[-2.0, 1.0],\n      kwargs...)\n\n PS_multipole(f_in;\n      int_s_min::Float64=1e-1, int_s_max::Float64=1e3,\n      L::Integer=0, N::Integer=1024, pr::Bool=true,\n      k0::Union{Nothing,Float64}=nothing,\n      right::Union{Float64,Nothing}=nothing)\n\nReturn the L-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation:\n\nP_L(k) = frac2 L + 1A^ (-i)^L  phi(s_mathrmeff) int_0^infty \n        mathrmd s  s^2  j_L(ks)  f_mathrmin(s)  \n        quad  A^ = frac14pi\n\nThe former method takes the name of the file where the TPCF multipole in exam is saved in, opens that file and pass the xs and  ys vector of values to the second method. All the keyword- arguments given to the first method are directly transferred to the second one.\n\nIn the second method, you have to pass the xs and ys values of the TPCF you want to exam. Internally, if epl==true the data are fitted with two power laws at the edges, creating a EPLs struct that is passed to the third method. The great advantage is that the integration can be extended over the limits imposed by the vector themself, increasing by far the precision of the PS computation.\n\nIn the last method, you have to give its function/spline f_in.\n\nIt's recommended to use either the first or the second method.\n\nThe analytical expression previously showed can be easily obtained from the  standard one:\n\nbeginsplit\n    P_L(k) = frac2 L + 1A (-i)^L  \n        int_0^infty mathrmd s_1  s_1^2 \n        int_0^infty mathrmd s  s^2 \n        int_-1^+1 mathrmd mu \n        j_L(ks)  xi(s_1 s mu)  phi(s_1)  phi(s_2) \n        mathcalL_L(mu) Fleft(fracss_1 mu right) \n        mathrmwith  s_2 = s_2(s_1 s μ) = sqrts_1^2 + s^2 + 2s_1smu\n         \n         quad A(s_mathrmmax s_mathrmmin theta_mathrmmax) \n        frac\n          V(s_mathrmmax s_mathrmmin theta_mathrmmax)\n          4  pi^2\nendsplit\n\nwith the definition\n\nf_mathrmin(s_1 s) =  int_-1^+1 mathrmd mu \n        xi(s_1 s mu)  phi(s_2) \n        mathcalL_L(mu)  Fleft(fracss_1 mu right)\n\nand the application of the effective redshift approximation.\n\nThe computation is made through the xicalc function of the  TwoFAST Julia package. Note that in the computation the integration range 0leq s leq infty  is reduced to int_s_min ≤ s ≤ int_s_max`\n\nOptional arguments\n\nint_s_min::Float64 = 1e-1 and int_s_max::Float64 = 1e3 : extremes of integration. Do not worry if the input TPCF is not defined in all the  integration range: it will be fitted with two power laws at its extremes,  thanks to the function EPLs\nN_left::Integer = 12 and N_right::Integer = 12 : number of points from left right edges to be used for the power law fitting in EPLs. They matters only if in the given input file ξ is not defined until the extremes of integration int_s_min and int_s_max\nL::Integer = 0: order of the Legendre polynomial to be used; note that  the multipole order L must be the same of the input TPCF in exam!  Otherwise, the results would have no sense at all!\npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nN::Integer = 1024 : number of points to be returned by xicalc\n\nReturns\n\nA Tuple{Vector{Float64}, Vector{Float64}} with:\n\nthe k values vector as first element;\nthe correspoding PS pk values vector as second one.\n\nSee also: V_survey, A, A_prime, EPLs,  print_PS_multipole\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/#GaPSE.print_PS_multipole","page":"Power Spectrum Multipoles","title":"GaPSE.print_PS_multipole","text":" print_PS_multipole(input::String, out::String;\n      L::Integer = 0, N::Integer = 1024,\n      pr::Bool = true, kwargs...)\n\nTakes in input a filename input where is stored a TPCF multipole, calculate the L-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation\n\nP_L(k) = frac2 L + 1A^ (-i)^L  phi(s_mathrmeff) int_0^infty \n        mathrmd s  s^2  j_L(ks)  f_mathrmin(s)  \n        quad  A^ = frac14pi\n\nand save it in the file out, together with the options used for the computation.\n\nOptional arguments\n\nL::Integer = 0: order of the Legendre polynomial to be used; note that  the multipole order L must be the same of the input TPCF in exam!  Otherwise, the results would have no sense at all!\npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nN::Integer = 1024 : number of points to be returned by xicalc\nkwargs... : other keyword arguments that will be passed to PS_multipole\n\nSee also: V_survey, A, A_prime, EPLs, PS_multipole\n\n\n\n\n\n","category":"function"},{"location":"","page":"Introduction","title":"Introduction","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"#GaPSE.jl-:-a-Galaxy-Power-Spectrum-Estimator","page":"Introduction","title":"GaPSE.jl : a Galaxy Power Spectrum Estimator","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is the documentation of GaPSE.jl package, an implementation of a Galaxy Power Spectrum Estimator written in Julia.","category":"page"},{"location":"#Documentation","page":"Introduction","title":"Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The documentation was built using Documenter.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Dates # hide\nprintln(\"Documentation built on $(now()) using Julia $(VERSION).\") # hide","category":"page"},{"location":"#Brief-description","page":"Introduction","title":"Brief description","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Measurements of the clustering of galaxies in Fourier space, at low wavenumbers, offer a window into the early Universe via the possible presence of scale dependent bias generated by Primordial Non Gaussianities [1] [2]. On such large scales, a Newtonian treatment of density of density perturbations might not be sufficient to describe the measurements, and a fully relativistic calculation should be employed.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In this program, we compute, for a given input matter power spectum (obtained from CLASS), all the GR effects two point auto-correlation and cross-correlation functions, for an arbitrary multipole order. This project, and the analytical expressions used for the TPCFs, are based on the article of Emanuele Castorina and Enea Di Dio [3]. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The most confortable way to use this code is through the Jupyter Notebooks: some .ipynb is already provided in the main directory, and we encourage you to follow the TUTORIAL.ipynb file first. The basic structure of the program and the most important functions are there presented.","category":"page"},{"location":"#Licence","page":"Introduction","title":"Licence","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This software is under the GNU 3.0 General Public Licence. See the file LICENCE.md.","category":"page"},{"location":"#Acknowledgements","page":"Introduction","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package make extensive use of Spline1D (from the  Dierckx[4] Julia package) and the Spherical Bessel Transform function xicalc (from the  TwoFAST[5] Julia package).","category":"page"},{"location":"#References","page":"Introduction","title":"References","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"<a id=\"1\">[1]</a>  Dalal, Doré et al., Imprints of primordial non-Gaussianities on large-scale structure (2008), American Physical Society, DOI: 10.1103/PhysRevD.77.123514,  url: https://journals.aps.org/prd/abstract/10.1103/PhysRevD.77.123514","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<a id=\"2\">[2]</a>  Slosar, Hirata et al., Constraints on local primordial non-Gaussianity from large scale structure (2008), Journal of Cosmology and Astroparticle Physics, DOI: 10.1088/1475-7516/2008/08/031, url: https://doi.org/10.1088/1475-7516/2008/08/031","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<a id=\"3\">[3]</a>  Castorina, Di Dio, The observed galaxy power spectrum in General Relativity (2022), Journal of Cosmology and Astroparticle Physics, DOI: 10.1088/1475-7516/2022/01/061, url: https://doi.org/10.1088/1475-7516/2022/01/061","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<a id=\"4\">[4]</a> Paul Dierckx, Curve and Surface Fitting with Splines (1993), Oxford University Press","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<a id=\"5\">[5]</a> Gebhardt, Jeong et al, Fast and accurate computation of projected two-point functions (2018), American Physical Society, DOI: 10.1103/PhysRevD.97.023504, url: https://link.aps.org/doi/10.1103/PhysRevD.97.023504","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#Index","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}
